---
title: React Compiler, Who Are You [2] - useMemoCache"
description: "Let's take a deep dive into useMemoCache, one of the key components of the React Compiler. We'll explore how useMemoCache works, examine its implementation, and learn about the experimental feature enableNoCloningMemoCache."
author: "Yongseok"
categories: ["React Compiler"]
date: '2024-05-26T03:30:51.104Z'
series: "React Compiler"
---
import LinkPreview from '../../../components/LinkPreview.astro'
import  { YouTube } from "../../../components/lit/youtube-element"


In the previous post, [React Compiler, ë„ˆ ëˆ„êµ¬ë‹ˆ [1]](https://yongsk0066.github.io/blog/react_compiler_1/), we looked at the overall structure of the React Compiler. \
Before diving into how the compiler works, let's first take a closer look at `useMemoCache`, which was mentioned frequently.

<LinkPreview src="https://github.com/facebook/react/pull/25143" />

This is the initial implementation PR for `useMemoCache`. Feel free to check it out if you're interested.

Let's first scan through the entire code and then examine it part by part.

https://github.com/facebook/react/blob/ee5c19493086fdeb32057e16d1e3414370242307/packages/react-reconciler/src/ReactFiberHooks.js#L1116

```ts
// react-reconciler/src/ReactFiberHooks.js
function useMemoCache(size: number): Array<any> {
  let memoCache = null;
  // Fast-path, load memo cache from wip fiber if already prepared
  let updateQueue: FunctionComponentUpdateQueue | null =
    (currentlyRenderingFiber.updateQueue: any);
  if (updateQueue !== null) {
    memoCache = updateQueue.memoCache;
  }
  // Otherwise clone from the current fiber
  if (memoCache == null) {
    const current: Fiber | null = currentlyRenderingFiber.alternate;
    if (current !== null) {
      const currentUpdateQueue: FunctionComponentUpdateQueue | null =
        (current.updateQueue: any);
      if (currentUpdateQueue !== null) {
        const currentMemoCache: ?MemoCache = currentUpdateQueue.memoCache;
        if (currentMemoCache != null) {
          memoCache = {
            // When enableNoCloningMemoCache is enabled, instead of treating the
            // cache as copy-on-write, like we do with fibers, we share the same
            // cache instance across all render attempts, even if the component
            // is interrupted before it commits.
            //
            // If an update is interrupted, either because it suspended or
            // because of another update, we can reuse the memoized computations
            // from the previous attempt. We can do this because the React
            // Compiler performs atomic writes to the memo cache, i.e. it will
            // not record the inputs to a memoization without also recording its
            // output.
            //
            // This gives us a form of "resuming" within components and hooks.
            //
            // This only works when updating a component that already mounted.
            // It has no impact during initial render, because the memo cache is
            // stored on the fiber, and since we have not implemented resuming
            // for fibers, it's always a fresh memo cache, anyway.
            //
            // However, this alone is pretty useful â€” it happens whenever you
            // update the UI with fresh data after a mutation/action, which is
            // extremely common in a Suspense-driven (e.g. RSC or Relay) app.
            data: enableNoCloningMemoCache
              ? currentMemoCache.data
              : // Clone the memo cache before each render (copy-on-write)
                currentMemoCache.data.map(array => array.slice()),
            index: 0,
          };
        }
      }
    }
  }
  // Finally fall back to allocating a fresh instance of the cache
  if (memoCache == null) {
    memoCache = {
      data: [],
      index: 0,
    };
  }
  if (updateQueue === null) {
    updateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = updateQueue;
  }
  updateQueue.memoCache = memoCache;

  let data = memoCache.data[memoCache.index];
  if (data === undefined) {
    data = memoCache.data[memoCache.index] = new Array(size);
    for (let i = 0; i < size; i++) {
      data[i] = REACT_MEMO_CACHE_SENTINEL;
    }
  } else if (data.length !== size) {
    // TODO: consider warning or throwing here
    if (__DEV__) {
      console.error(
        'Expected a constant size argument for each invocation of useMemoCache. ' +
          'The previous cache was allocated with size %s but size %s was requested.',
        data.length,
        size,
      );
    }
  }
  memoCache.index++;
  return data;
}
```

Now, let's go through the hook step by step.

### Fast Path

The first operation is to find the `memoCache` from the `updateQueue` of the currently rendering fiber.\
If it has been called (rendered) before, it will exist. This prevents unnecessary cache allocation.

```ts
let memoCache = null;
// Fast-path, load memo cache from wip fiber if already prepared
let updateQueue: FunctionComponentUpdateQueue | null =
  (currentlyRenderingFiber.updateQueue: any);
if (updateQueue !== null) {
  memoCache = updateQueue.memoCache;
}
```


### If There's No Cache? Clone Cache from Alternate Fiber

If there is no `memoCache` in the `updateQueue` of the currently rendering fiber, it checks the alternate fiber.

In React's Fiber architecture, each Fiber node belongs to either the 'current' tree or the 'workInProgress' tree. 
The 'current' tree represents the state of the components currently rendered on the screen, 
and the 'workInProgress' tree represents the state that React is trying to apply updates to. The alternate fiber mentioned here is the alternate of currentlyRenderingFiber, 
which is the workInProgress tree, so it points to the Fiber in the current tree.

It clones the cache from this alternate fiber (current) and uses it.

To focus on the flow of the logic, I temporarily removed the conditional statements. You can see the original code above.

```ts
let memoCache = null;
// ...
// If there's no cache, clone the cache from the alternate fiber
if (memoCache == null) {

  const current = currentlyRenderingFiber.alternate; // Get the alternate fiber (current)
  const currentUpdateQueue = current.updateQueue;    // Get the updateQueue of the alternate fiber
  const currentMemoCache: ?MemoCache = currentUpdateQueue.memoCache; // Get the memoCache of the alternate fiber

  memoCache = {
    data: enableNoCloningMemoCache
      ? currentMemoCache.data
      : // Clone the memo cache before each render (copy-on-write)
        currentMemoCache.data.map(array => array.slice()),
    index: 0,
  };
}
```

During the process of copying the cache, the behavior differs based on the `enableNoCloningMemoCache`option.\ 
Depending on the `enableNoCloningMemoCache` flag, it decides whether to use the cache data as is or make a shallow copy.
- If <b>enabled</b>, it uses the cache data as is. This can reduce memory usage but carries the risk of the cache data being modified.
- If <b>disabled</b>, it makes a shallow copy of the cache data and uses it. This allows safe usage of the cache data from the previous rendering but can increase memory usage.

<LinkPreview src="https://github.com/facebook/react/pull/28878" />

There's a long comment attached to this part. Let's take a look at that as well. 

```plaintext
When `enableNoCloningMemoCache` is enabled, 
instead of treating the cache as copy-on-write, 
like we do with fibers, we share the same cache instance across all render attempts, 
even if the component is interrupted before it commits.

If an update is interrupted, 
either because it suspended or because of another update, 
we can reuse the memoized computations from the previous attempt. 
We can do this because the React Compiler performs atomic writes to the memo cache, 
i.e. it will not record the inputs to a memoization without also recording its output.

This gives us a form of "resuming" within components and hooks.

This only works when updating a component that already mounted. 
It has no impact during initial render, 
because the memo cache is stored on the fiber, 
and since we have not implemented resuming for fibers, 
it's always a fresh memo cache, anyway.

However, this alone is pretty useful 
â€” it happens whenever you update the UI with fresh data after a mutation/action,
which is extremely common in a Suspense-driven (e.g. RSC or Relay) app.
```

What does it mean that `the React Compiler performs atomic writes to the memo cache, i.e. it will not record the inputs to a memoization without also recording its output`?
>  ğŸ¤·â€â™‚ï¸ Why is the word 'atomic' used here? 

The word 'atomic' is used to mean 'indivisible' here. (Let's not say "Atoms can be split too?") \
In computer science, an 'atomic operation' refers to an operation that cannot be further divided, meaning it either executes completely in one step or not at all.

<aside>This concept is commonly used in multi-threaded environments. In a multi-threaded environment, multiple threads can access the same resource simultaneously, so it's important to prevent other threads from accessing the resource while one thread is using it. This is where 'atomic operations' are used.</aside>

<b>Let's take an example.</b> \
Consider a bank transfer. If we transfer $100r from account A to account B, this operation consists of two steps:

- Deducting $100 from account A
- Adding $100 dollar to account B

What would happen if there's a problem between these steps and the process is <b>interrupted</b>?  \
Account A would have lost $100, but account B wouldn't have received it. To prevent such situations, <b>'atomic operations'</b> are necessary.\
In other words, the transfer operation should either execute completely or not at all.

The React Compiler's memoization process uses a similar concept. Let's explain with an example.

Let's compile the following code:

```tsx
function Component({ active }) {
  let color: string;
  if (active) {
    color = "red";
  } else {
    color = "blue";
  }
  return <div styles={{ color }}>hello world</div>;
}
```

When compiled, it gets transformed to:
  
```tsx
function Component(t0) {
  const $ = _c(2);

  const { active } = t0;
  let color;

  if (active) {
    color = "red";
  } else {
    color = "blue";
  }

  let t1;

  if ($[0] !== color) {
    t1 = (
      <div styles={{ color }}>hello world</div>
    );
    $[0] = color;
    $[1] = t1;
  } else {
    t1 = $[1];
  }

  return t1;
}
```

The part we should focus on here is:

```ts
if ($[0] !== color) {
  t1 = (
    <div styles={{ color }}>hello world</div>
  );
  $[0] = color;
  $[1] = t1;
} else {
  t1 = $[1];
}
```
ë¨¼ì € ê°„ë‹¨íˆ ë™ì‘ì„ ì„¤ëª…í•´ë³´ì.
`$`ëŠ” memoCacheë¥¼ ì˜ë¯¸í•œë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” `$[0]`ì—ëŠ” ì´ì „ì— ì €ì¥ëœ color ê°’ì„ ì €ì¥í•˜ê³ , `$[1]`ì—ëŠ” ì´ì „ì— ë Œë”ë§ëœ ê²°ê³¼ë¥¼ ì €ì¥í•˜ê³  ìˆë‹¤.\
`if ($[0] !== color)` ìºì‹œëœ colorê°’ê³¼ í˜„ì¬ colorê°’ì„ ë¹„êµí•œë‹¤. ë§Œì•½ ë‹¤ë¥´ë‹¤ë©´, ìƒˆë¡œìš´ colorì— ëŒ€í•œ ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ìƒì„±í•´ì•¼í•œë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤.\
ì´ë•Œ ìƒˆë¡œìš´ ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ìƒì„±í•˜ê³ , `$[0]`ì— ìƒˆë¡œìš´ colorê°’ì„ ì €ì¥í•˜ê³ , `$[1]`ì— ìƒˆë¡œìš´ ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ì €ì¥í•œë‹¤.\
ê·¸ë ‡ì§€ ì•Šë‹¤ë©´, ì´ì „ì— ë Œë”ë§ëœ ê²°ê³¼ë¥¼ ì‚¬ìš©í•œë‹¤.

ì—¬ê¸°ì„œ ì¤‘ìš”í•œ ì ì€ `$[0] = color;`ì™€ `$[1] = t1;`ì´ ê°™ì€ ë¸”ë¡ ë‚´ì—ì„œ ì—°ì†ì ìœ¼ë¡œ ì¼ì–´ë‚œë‹¤ëŠ” ê²ƒì´ë‹¤.\
ì´ê²ƒì´ ë°”ë¡œ <b>'ì›ìì  ì“°ê¸°'</b>ì´ë‹¤.

ì´ ë‘ ì¤„ì€ í•˜ë‚˜ì˜ ì›ìì  ì—°ì‚°ìœ¼ë¡œ ì²˜ë¦¬ë˜ê¸°ì—, color ê°’ì´ ìºì‹œì— ì“°ì´ë©´, ê·¸ì— í•´ë‹¹í•˜ëŠ” ì—˜ë¦¬ë¨¼íŠ¸ë„ ë°˜ë“œì‹œ ìºì‹œì— ì“°ì¸ë‹¤. ì´ë“¤ ì‚¬ì´ì˜ ì¤‘ê°„ ìƒíƒœëŠ” ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤.\
ì´ì œ React Compilerì˜ ì›ìì  ì“°ê¸°ê°€ ë¬´ì—‡ì„ ì˜ë¯¸í•˜ëŠ”ì§€ ì•Œê²Œ ë˜ì—ˆë‹¤.

ë‹¤ì‹œ ë³¸ë˜ ë‚´ìš©ìœ¼ë¡œ ëŒì•„ê°€ ë³´ì.\
`enableNoCloningMemoCache`ê°€ false ë¼ë©´ ê° ë Œë”ë§ ì‹œë„ì‹œ ì´ì „ ë Œë”ë§ì˜ ìºì‹œë¥¼ ë³µì‚¬í•˜ê³  ì´ ë³µì‚¬ë³¸ì„ ìˆ˜ì •í•˜ëŠ” ì‹ìœ¼ë¡œ (copy-on-write) ì‚¬ìš©í•œë‹¤.\
í•˜ì§€ë§Œ ì´ ë°©ë²•ì€ ë Œë”ë§ì´ ì¤‘ë‹¨ë˜ê³  ì¬ê°œë  ë•Œë§ˆë‹¤ ìºì‹œë¥¼ ë³µì‚¬í•˜ë¯€ë¡œ, ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì¦ê°€í•  ìˆ˜ ìˆë‹¤.

`enableNoCloningMemoCache`ê°€ trueë¼ë©´ ëª¨ë“  ë Œë”ë§ ì‹œë„ì—ì„œ ë™ì¼í•œ ìºì‹œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê³µìœ í•œë‹¤.

ì¦‰, ë Œë”ë§ì´ ì¤‘ë‹¨(suspended/interrupted)ë˜ê³  ì¬ê°œ ë˜ë”ë¼ë„, ì´ì „ ë Œë”ë§ ì‹œë„ì—ì„œì˜ ìºì‹œë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.\
ì´ëŠ” ë©”ëª¨ë¦¬ ê´€ë¦¬ì— ìˆì–´ì„œ í° ì´ì ì´ë‹¤. 

ì´ëŸ° ë™ì‘ì´ ê°€ëŠ¥í•˜ë ¤ë©´ React ì»´íŒŒì¼ëŸ¬ê°€ ë©”ëª¨ ìºì‹œì— ëŒ€í•´ ì›ìì  ì“°ê¸°ë¥¼ ìˆ˜í–‰í•´ì•¼ í•œë‹¤ëŠ” ê²ƒì´ë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ë³´ì¥ë˜ì§€ ì•Šì•˜ë‹¤ë©´, ì•„ë˜ì™€ ê°™ì€ ë¬¸ì œê°€ ë°œìƒí–ˆì„ ê²ƒì´ë‹¤.

1. 'A'ë Œë”ë§ ì‹œë„ê°€ color ê°’ì„ 'red'ë¡œ ìºì‹œì— ì €ì¥í•œë‹¤.
2. ê·¸ëŸ¬ë‚˜ ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ìºì‹œì— ê¸°ë¡í•˜ê¸° ì „ì—, ë Œë”ë§ì´ ì¤‘ë‹¨ë˜ì–´ë²„ë¦°ë‹¤.
3. 'B'ë Œë”ë§ ì‹œë„ê°€ ì‹œì‘ë˜ë©´, ì´ë•Œ ìºì‹œì—ëŠ” colorì— ëŒ€í•œ ì…ë ¥ì€ ìˆì§€ë§Œ, ì¶œë ¥ì´ ì—†ëŠ” ìƒíƒœê°€ ëœë‹¤.

ì´ëŠ” ìºì‹œ ë¶ˆì¼ì¹˜ ë¬¸ì œë¥¼ ë°œìƒì‹œí‚¤ê³  ì´ëŠ” ë Œë”ë§ ê²°ê³¼ì˜ ë¶ˆì¼ì¹˜ë¡œ ì´ì–´ì§ˆ ê²ƒì´ë‹¤. \
ìƒíƒœì— ë”°ë¥¸ ë Œë”ë§ ë¶ˆì¼ì¹˜ ë¬¸ì œ... ì–´ë””ì„œ ë“¤ì–´ë³¸ì ì´ ìˆì§€ ì•Šë‚˜ìš”? 'useSyncExternalStore'ë¥¼ ì„¤ëª…í•  ë•Œ ë‚˜ì˜¤ëŠ” tearing ë¬¸ì œì™€ ë¹„ìŠ·í•˜ë‹¤.

<LinkPreview src="https://github.com/reactwg/react-18/discussions/69"/>

í•˜ì§€ë§Œ 'ì›ìì  ì“°ê¸°'ê°€ ë³´ì¥ëœë‹¤ë©´, colorì— ëŒ€í•œ ìºì‹œê°€ ìˆë‹¤ëŠ” ê²ƒì€ ë°˜ë“œì‹œ ì—˜ë¦¬ë¨¼íŠ¸ì— ëŒ€í•œ ìºì‹œë„ ìˆë‹¤ëŠ” ê²ƒì„ ë³´ì¥ ë°›ì„ ìˆ˜ ìˆë‹¤.


íœ´, ë­”ê°€ ê½¤ë‚˜ ë©€ë¦¬ ì™”ë‹¤. ì´ì œ ë‹¤ì‹œ `useMemoCache`ë¡œ ëŒì•„ê°€ë³´ì.

`enableNoCloningMemoCache`ì¡°ê±´ì— ë”°ë¥¸ ë¶„ê¸°ë¥¼ ë³´ë‹¤ê°€ ì—¬ê¸°ê¹Œì§€ ì™”ë‹¤.
ê·¸ë˜ì„œ `enableNoCloningMemoCache`ëŠ” ì°¸ì´ëƒ ê±°ì§“ì´ëƒ!

```ts
// react/shared/ReactFeatureFlags.js

// Test this at Meta before enabling.
export const enableNoCloningMemoCache = false;
```
í˜„ ì‹œì ì—ì„œëŠ” `enableNoCloningMemoCache`ëŠ” falseë¡œ ì„¤ì •ë˜ì–´ ìˆë‹¤.

ë‹¤ì‹œ `useMemoCache`ë¡œ ëŒì•„ê°€ë³´ì.

### ìºì‹œê°€ ì—†ë‹¤ë©´? ìƒˆë¡œìš´ ìºì‹œ ìƒì„±

ì´ì œ ë§ˆì§€ë§‰ìœ¼ë¡œ ìºì‹œê°€ ì—†ë‹¤ë©´, ìƒˆë¡œìš´ ìºì‹œë¥¼ ìƒì„±í•œë‹¤.

```ts
if (memoCache == null) {
  memoCache = {
    data: [],
    index: 0,
  };
}
```

### ìºì‹œ í• ë‹¹

updateQueueê°€ ì—†ë‹¤ë©´ ìƒˆë¡œ ë§Œë“¤ê³ , memoCacheë¥¼ í• ë‹¹í•œë‹¤.

```ts
if (updateQueue === null) {
  updateQueue = createFunctionComponentUpdateQueue();
  currentlyRenderingFiber.updateQueue = updateQueue;
}
updateQueue.memoCache = memoCache;
```

`createFunctionComponentUpdateQueue`ëŠ” ê¸°ë³¸ì ì¸ queueê°ì²´ë¥¼ return í•œë‹¤. 
enableUseMemoCacheHook í”Œë˜ê·¸ì— ë”°ë¼ ë‚˜ë‰˜ëŠ”ë° í˜„ì¬ëŠ” trueë˜ì–´ìˆë‹¤.

```ts
// NOTE: defining two versions of this function to avoid size impact when this feature is disabled.
// Previously this function was inlined, the additional `memoCache` property makes it not inlined.
// ë©”ëª¨ : ì´ ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆì„ ë•Œ í¬ê¸° ì˜í–¥ì„ í”¼í•˜ê¸° ìœ„í•´ ì´ í•¨ìˆ˜ì˜ ë‘ ê°€ì§€ ë²„ì „ì„ ì •ì˜í•©ë‹ˆë‹¤.
// ì´ì „ì— ì´ í•¨ìˆ˜ëŠ” ì¸ë¼ì¸ìœ¼ë¡œ ì •ì˜ë˜ì—ˆìœ¼ë©°, ì¶”ê°€ì ì¸ `memoCache` ì†ì„±ìœ¼ë¡œ ì¸í•´ ì¸ë¼ì¸ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
let createFunctionComponentUpdateQueue: () => FunctionComponentUpdateQueue;
if (enableUseMemoCacheHook) {
  createFunctionComponentUpdateQueue = () => {
    return {
      lastEffect: null,
      events: null,
      stores: null,
      memoCache: null,
    };
  };
} else {
  createFunctionComponentUpdateQueue = () => {
    return {
      lastEffect: null,
      events: null,
      stores: null,
    };
  };
}
```

### ìºì‹œ ë°ì´í„° ë°˜í™˜

ë§ˆì§€ë§‰ìœ¼ë¡œ ìºì‹œ ë°ì´í„°ë¥¼ ë°˜í™˜í•œë‹¤.

ìºìƒˆë¡œ ë¶€í„° ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ê³ ,

```ts
let data = memoCache.data[memoCache.index]; 
```

ë°ì´í„°ê°€ ì—†ë‹¤ë©´ ìƒˆë¡œìš´ ë°ì´í„°ë¥¼ í• ë‹¹í•˜ê³ , `REACT_MEMO_CACHE_SENTINEL`ë¡œ ì´ˆê¸°í™”í•œë‹¤.\
`REACT_MEMO_CACHE_SENTINEL`ì€ memoizationì´ ë˜ì§€ ì•Šì€ ìƒíƒœë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.\
í˜¸ì¶œ ë³„ë¡œ ìºì‹œëŠ” Arrayí˜•íƒœë¡œ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì— Arrayë¡œ ì´ˆê¸°í™”í•œë‹¤.

```ts
if (data === undefined) { 
  data = memoCache.data[memoCache.index] = new Array(size);
  for (let i = 0; i < size; i++) {
    data[i] = REACT_MEMO_CACHE_SENTINEL;
  }
}
```

ë§Œì•½ dataê°€ `undefined`ê°€ ì•„ë‹ˆë¼ë©´, ì¦‰ ìºì‹œ ë°ì´í„°ê°€ ì¡´ì¬í•œë‹¤ë©´, dataì˜ ê¸¸ì´ê°€ ìš”ì²­ëœ sizeì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤.\
í™•ì¸í•˜ëŠ” ì´ìœ ëŠ”, ì´ì „ ë Œë”ë§ì—ì„œ ì‚¬ìš©ëœ ìºì‹œ ë°ì´í„°ì™€ í˜„ì¬ ë Œë”ë§ì—ì„œ ì‚¬ìš©í•  ìºì‹œ ë°ì´í„°ì˜ ê¸¸ì´ê°€ ë‹¤ë¥´ë‹¤ë©´, ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.

```ts
else if (data.length !== size) {
  if (__DEV__) {
    console.error(
      'useMemoCacheì˜ ê° í˜¸ì¶œì— ëŒ€í•´ ìƒìˆ˜ í¬ê¸° ì¸ìˆ˜ê°€ ì˜ˆìƒë©ë‹ˆë‹¤.' +
        'ì´ì „ ìºì‹œëŠ” í¬ê¸° %së¡œ í• ë‹¹ë˜ì—ˆì§€ë§Œ í¬ê¸° %sê°€ ìš”ì²­ë˜ì—ˆìŠµë‹ˆë‹¤.',
      data.length,
      size,
    );
  }
}
```

ë§ˆì§€ë§‰ìœ¼ë¡œ ìºì‹œ ì¸ë±ìŠ¤ë¥¼ ì¦ê°€ì‹œí‚¤ê³  ë°ì´í„°ë¥¼ ë°˜í™˜í•œë‹¤.

```ts
memoCache.index++;
return data;
```

ì´ì „ í¸ì—ì„œ ì‚´í´ë´¤ë˜ 'react-compiler-runtime'ì—ì„œì˜ êµ¬í˜„ê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ, ì¡°ê¸ˆë” Fiberì— ë§ê²Œ ìˆ˜ì •ëœ ë¶€ë¶„ì´ ìˆë‹¤.

### `useMemo`ì™€ `useMemoCache` ì°¨ì´

ìš°ë¦¬ì—ê² ìµìˆ™í•œ, ê·¸ë¦¬ê³  ì´ì œ ìŠí˜€ì§€ê²Œ ë  `useMemo`. ì´ë¦„ë„ ë¹„ìŠ·í•œ íƒ“ì— ì°¨ì´ì— ëŒ€í•œ ì˜ë¬¸ì„ ê°€ì§ˆ ìˆ˜ ìˆì„ ê²ƒì´ë‹¤.

ê°„ë‹¨í•˜ê²Œ `useMemo`ì˜ êµ¬í˜„ì„ ëŒì•„ë³´ì.

```ts
function mountMemo<T>(
  nextCreate: () => T,
  deps: Array<mixed> | void | null,
): T {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function updateMemo<T>(
  nextCreate: () => T,
  deps: Array<mixed> | void | null,
): T {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps; //
  const prevState = hook.memoizedState;
  if (prevState !== null) {
    // Assume these are defined. If they're not, areHookInputsEqual will warn.
    if (nextDeps !== null) {
      const prevDeps: Array<mixed> | null = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) { // ì´ì „ depsì™€ í˜„ì¬ depsê°€ ê°™ë‹¤ë©´ ì´ì „ ê°’ì„ ë°˜í™˜
        return prevState[0];
      }
    }
  }
  const nextValue = nextCreate(); // ìƒˆë¡œìš´ ê°’ ìƒì„±
  hook.memoizedState = [nextValue, nextDeps]; // ìƒˆë¡œìš´ ê°’ê³¼ depsë¥¼ ì €ì¥
  return nextValue; // ìƒˆë¡œìš´ ê°’ ë°˜í™˜
}
```

ë‘˜ë‹¤ ë©”ëª¨ì´ì œì´ì…˜ì„ ìœ„í•œ í›…ì´ì§€ë§Œ ì¡°ê¸ˆ ë‹¤ë¥´ë‹¤, `useMemo`ëŠ” ê°œë°œìê°€ ì§ì ‘ì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” í›…ìœ¼ë¡œ, ì˜ì¡´ì„± ë°°ì—´ì„ ë°›ì•„ì„œ ì˜ì¡´ì„±ì´ ë³€ê²½ë˜ì—ˆì„ ë•Œë§Œ ìƒˆë¡œìš´ ê°’ì„ ìƒì„±í•œë‹¤.\
`useMemo`ëŠ” ì˜ì¡´ì„± ë°°ì—´ì„ í†µí•´ ë©”ëª¨ì´ì œì´ì…˜ ì—¬ë¶€ë¥¼ í›…ì´ ì±…ì„ì§€ëŠ” ê²ƒì´ë‹¤.\
ë°˜ë©´ `useMemoCache`ëŠ” ì»´íŒŒì¼ëŸ¬ ë‚´ë¶€ì—ì„œ ì‚¬ìš©í•˜ëŠ” í›…ìœ¼ë¡œ, ì˜ì¡´ì„± ë°°ì—´ì„ ë°›ì§€ ì•Šê³ , ìºì‹œë¥¼ ê´€ë¦¬í•˜ëŠ” ê²ƒì´ ì£¼ ëª©ì ì´ë‹¤.\
ê·¸ë ‡ê¸° ë©”ëª¨ì´ì œì´ì…˜ì˜ ì±…ì„ì€ `useMemoCache`ê°€ ì•„ë‹Œ ì»´íŒŒì¼ëŸ¬ê°€ ë§¡ëŠ”ë‹¤.

### `useMemoCache`ì˜ í…ŒìŠ¤íŠ¸ ì½”ë“œ

ì´ì œ `useMemoCache`ë¥¼ ì‚¬ìš©í•˜ëŠ” ì˜ˆì‹œ ì½”ë“œë¥¼ ì‚´í´ë³´ì.\
ì¢‹ì€ ì˜ˆì‹œë“¤ì´ í…ŒìŠ¤íŠ¸ ì½”ë“œì— ë§ì´ ìˆê¸° ë•Œë¬¸ì—, í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‚´í´ë³´ë©´ ë™ì‘ì„ ì´í•´í•˜ëŠ”ë° ë„ì›€ì´ ë  ê²ƒì´ë‹¤.

```ts
// ë¹„ì‹¼ ê³„ì‚°ì„ í•˜ëŠ” í•¨ìˆ˜
function someExpensiveProcessing(t) { 
  Scheduler.log(`Some expensive processing... [${t}]`);
  return t;
}

// ì„œìŠ¤íŒ¬ìŠ¤ë¥¼ íŠ¸ë¦¬ê±° í•˜ê¸°ìœ„í•œ í•¨ìˆ˜
function useWithLog(t, msg) { 
  try {
    return React.use(t); 
  } catch (x) {
    Scheduler.log(`Suspend! [${msg}]`);
    throw x;
  }
}

function Data({chunkA, chunkB}) { 
  const a = someExpensiveProcessing(useWithLog(chunkA, 'chunkA')); 
  const b = useWithLog(chunkB, 'chunkB');
  return (
    <>
      {a}
      {b}
    </>
  );
}

function Input() {
  const [input, _setText] = useState('');
  return input;
}

function App({chunkA, chunkB}) {
  return (
    <>
      <div>
        Input: <Input />
      </div>
      <div>
        Data: <Data chunkA={chunkA} chunkB={chunkB} />
      </div>
    </>
  );
}
```
ì´ì™€ ê°™ì€ í˜•íƒœì˜ ì»´í¬ë„ŒíŠ¸ë“¤ì˜ ì»´íŒŒì¼ ê²°ê³¼ë¬¼ì„ ê°€ì§€ê³  í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰í•´ë³´ì.\
Data ì»´í¬ë„ŒíŠ¸ëŠ” chunkAì™€ chunkBë¥¼ ë°›ì•„ì™€ì„œ, chunkAì— ëŒ€í•œ ë¹„ì‹¼ ê³„ì‚°ì„ ìˆ˜í–‰í•˜ê³ , chunkBëŠ” ê·¸ëŒ€ë¡œ ë°˜í™˜í•œë‹¤.

```ts
// react-reconciler/src/__tests__/useMemoCache-test.js
test('ì—…ë°ì´íŠ¸ ì¤‘ì— ì¤‘ë‹¨ëœ(suspended/interrupted) ë Œë”ë§ ì‹œë„ì—ì„œì˜ ê³„ì‚°ì„ ì¬ì‚¬ìš©í•©ë‹ˆë‹¤', async () => { 
  // This test demonstrates the benefit of a shared memo cache. By "shared" I
  // mean multiple concurrent render attempts of the same component/hook use
  // the same cache. (When the feature flag is off, we don't do this â€” the
  // cache is copy-on-write.)
  // ì´ í…ŒìŠ¤íŠ¸ëŠ” ê³µìœ  ë©”ëª¨ ìºì‹œì˜ ì´ì ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. "ê³µìœ "ë¼ëŠ” ë§ì€ ë™ì¼í•œ ì»´í¬ë„ŒíŠ¸/í›…ì˜
  // ì—¬ëŸ¬ ë™ì‹œ ë Œë”ë§ ì‹œë„ê°€ ë™ì¼í•œ ìºì‹œë¥¼ ì‚¬ìš©í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. 
  // (ê¸°ëŠ¥ í”Œë˜ê·¸ê°€ êº¼ì ¸ ìˆìœ¼ë©´ ì´ë ‡ê²Œ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ - ìºì‹œëŠ” ë³µì‚¬ë³¸ì…ë‹ˆë‹¤.)


  function Data(t0) {
    const $ = useMemoCache(5);
    const {chunkA, chunkB} = t0;
    const t1 = useWithLog(chunkA, 'chunkA');
    let t2;

    if ($[0] !== t1) {
      t2 = someExpensiveProcessing(t1);
      $[0] = t1;
      $[1] = t2;
    } else {
      t2 = $[1];
    }

    const a = t2;
    const b = useWithLog(chunkB, 'chunkB');
    let t3;

    if ($[2] !== a || $[3] !== b) {
      t3 = (
        <>
          {a}
          {b}
        </>
      );
      $[2] = a;
      $[3] = b;
      $[4] = t3;
    } else {
      t3 = $[4];
    }

    return t3;
  }

  let setInput;
  function Input() {
    const [input, _set] = useState('');
    setInput = _set;
    return input;
  }

  function App(t0) {
    const $ = useMemoCache(4);
    const {chunkA, chunkB} = t0;
    let t1;

    if ($[0] === Symbol.for('react.memo_cache_sentinel')) {
      t1 = (
        <div>
          Input: <Input />
        </div>
      );
      $[0] = t1;
    } else {
      t1 = $[0];
    }

    let t2;

    if ($[1] !== chunkA || $[2] !== chunkB) {
      t2 = (
        <>
          {t1}
          <div>
            Data: <Data chunkA={chunkA} chunkB={chunkB} />
          </div>
        </>
      );
      $[1] = chunkA;
      $[2] = chunkB;
      $[3] = t2;
    } else {
      t2 = $[3];
    }

    return t2;
  }

  // Resolved í”„ë¡œë¯¸ìŠ¤ ìƒì„±
  function createInstrumentedResolvedPromise(value) {
    return {
      then() {},
      status: 'fulfilled',
      value,
    };
  }

  // Pending í”„ë¡œë¯¸ìŠ¤ ìƒì„±
  function createDeferred() { 
    let resolve;  
    const p = new Promise(res => { 
      resolve = res;
    });
    p.resolve = resolve;
    return p;  
  }
```

ì»´íŒŒì¼ëœ ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì´ì œ í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰í•´ë³´ì.


#### ì²« ë²ˆì§¸ ë Œë”ë§

ìµœì´ˆ ë Œë”ë§ì—ì„œëŠ” `chunkA`ì™€ `chunkB`ë¥¼ ë°›ì•„ì™€ì„œ `Data` ì»´í¬ë„ŒíŠ¸ë¥¼ ë Œë”ë§í•œë‹¤.\
`createInstrumentedResolvedPromise`ëŠ” Resolvedëœ í”„ë¡œë¯¸ìŠ¤ë¥¼ ìƒì„±í•œë‹¤. ì¦‰ ì´ë¯¸ ë°›ì•„ì˜¨ ë°ì´í„°ë¥¼ ì˜ë¯¸í•œë‹¤. \
ì´ë•ŒëŠ” A1ì— ê±¸ë ¤ìˆëŠ” expensive processì— ëŒ€í•œ ë¡œê·¸ê°€ ì°íˆê³ , `Data` ì»´í¬ë„ŒíŠ¸ëŠ” `A1B1`ì„ ë°˜í™˜í•œë‹¤.


```ts
// Initial render. We pass the data in as two separate "chunks" to simulate a stream (e.g. RSC).
// ìµœì´ˆ ë Œë”ë§. ë°ì´í„°ë¥¼ ë‘ ê°œì˜ ë³„ë„ "ì²­í¬"ë¡œ ì „ë‹¬í•˜ì—¬ ìŠ¤íŠ¸ë¦¼(ì˜ˆ: RSC)ì„ ì‹œë®¬ë ˆì´ì…˜í•©ë‹ˆë‹¤.
const root = ReactNoop.createRoot();
const initialChunkA = createInstrumentedResolvedPromise('A1'); // A1ë¡œ resolveëœ í”„ë¡œë¯¸ìŠ¤ ìƒì„±
const initialChunkB = createInstrumentedResolvedPromise('B1'); // B1ë¡œ resolveëœ í”„ë¡œë¯¸ìŠ¤ ìƒì„±
await act(() => 
  root.render(<App chunkA={initialChunkA} chunkB={initialChunkB} />), // ì´ˆê¸° ë Œë”ë§
);
assertLog(['Some expensive processing... [A1]']); // 
expect(root).toMatchRenderedOutput(
  <>
    <div>Input: </div>
    <div>Data: A1B1</div>
  </>,
);
```

#### ì „í™˜ì¤‘ì— UI ì—…ë°ì´íŠ¸

```ts
const updatedChunkA = createDeferred(); 
const updatedChunkB = createDeferred(); 
```

`createDeferred` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ `updatedChunkA`ì™€ `updatedChunkB`ë¼ëŠ” ë‘ ê°œì˜ Promise ê°ì²´ë¥¼ ìƒì„±í•œë‹¤. ì´ ê°ì²´ë“¤ì€ ë‚˜ì¤‘ì— ë°ì´í„°ë¥¼ ë¡œë“œí•˜ëŠ” ë° ì‚¬ìš©ëœë‹¤

```ts
await act(() => {
  React.startTransition(() => {
    root.render(<App chunkA={updatedChunkA} chunkB={updatedChunkB} />);
  });
});
```

`React.startTransition`ì„ ì‚¬ìš©í•˜ì—¬ UI ì—…ë°ì´íŠ¸ë¥¼ ì‹œì‘í•œë‹¤. transitionì€ ë‚®ì€ ìš°ì„ ìˆœìœ„ë¡œ ìŠ¤ì¼€ì¤„ë§ë˜ì–´, ë‹¤ë¥¸ ì‘ì—…ì´ ëë‚œ í›„ì— ì‹¤í–‰ëœë‹¤.\
ì´ë•Œ `App` ì»´í¬ë„ŒíŠ¸ì— `updatedChunkA`ì™€ `updatedChunkB`ë¥¼ ì „ë‹¬í•˜ì—¬ ë Œë”ë§í•œë‹¤.

```ts
assertLog(['Suspend! [chunkA]']); 
```
```ts
  const t1 = useWithLog(chunkA, 'chunkA');
```
`useWithLog` í•¨ìˆ˜ì—ì„œ `chunkA`ì— ëŒ€í•œ `useWithLog`ê°€ ì‹¤í–‰ë˜ê³ , pending ì¤‘ì— ìˆìŒìœ¼ë¡œ `use`ì— ì˜í•´ì„œ Suspenseê°€ íŠ¸ë¦¬ê±° ë˜ê³  'Suspend! [chunkA]'ê°€ ì°íˆê²Œ ëœë‹¤.

```ts
await act(() => updatedChunkA.resolve('A2'));
```
`updatedChunkA`ë¥¼ 'A2'ë¡œ resolveí•œë‹¤.

```ts
const t1 = useWithLog(chunkA, 'chunkA');
let t2;

if ($[0] !== t1) {
  t2 = someExpensiveProcessing(t1);
  $[0] = t1;
  $[1] = t2;
} else {
  t2 = $[1];
}
const a = t2;
const b = useWithLog(chunkB, 'chunkB');

```
ë°ì´í„°ê°€ ì¤€ë¹„ë˜ì—ˆìœ¼ë¯€ë¡œ, ë Œë”ë§ì´ ì¬ê°œ ë˜ê³ , `useWithLog`ê°€ ì‹¤í–‰ëœë‹¤.\
ì´ë•Œ `t1`ì€ 'A2'ê°€ ë˜ê³ , `$[0]`ì—ëŠ” ì´ì „ì— ì €ì¥ëœ 'A1'ê³¼ ë¹„êµí•˜ì—¬ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— expensive processê°€ ì‹¤í–‰ëœë‹¤.\
ê·¸ì— ë”°ë¼ 'Some expensive processing... [A2]'ê°€ ì°íˆê²Œ ëœë‹¤.

ë°”ë¡œ ë‹¤ìŒìœ¼ë¡œ `useWithLog`ê°€ ì‹¤í–‰ë˜ê³ , chunkBëŠ” ì•„ì§ resolveë˜ì§€ ì•Šì•˜ê¸°ì— 'Suspend! [chunkB]'ê°€ ì°íˆê²Œ ëœë‹¤.\
ë‹¤ì‹œ ë Œë”ë§ì´ ì¤‘ë‹¨ë˜ì—ˆê¸° ë•Œë¬¸ì—, ì´ˆê¸° UIë¥¼ ê·¸ëŒ€ë¡œ ë³´ì—¬ì¤€ë‹¤.

```ts
expect(root).toMatchRenderedOutput(
  <>
    <div>Input: </div>
    <div>Data: A1B1</div>
  </>,
);
```


#### ì—…ë°ì´íŠ¸ ì „í™˜ ì¤‘ ë‹¤ë¥¸ ë¶€ë¶„ ì—…ë°ì´íŠ¸

```ts
// While waiting for the data to finish loading, update a different part of the screen. This interrupts the refresh transition.
// ë°ì´í„° ë¡œë“œê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” ë™ì•ˆ í™”ë©´ì˜ ë‹¤ë¥¸ ë¶€ë¶„ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤. ì´ëŠ” ìƒˆë¡œ ê³ ì¹¨ ì „í™˜ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.
//
// In a real app, this might be an input or hover event.
// ì‹¤ì œ ì•±ì—ì„œëŠ” ì…ë ¥ ë˜ëŠ” í˜¸ë²„ ì´ë²¤íŠ¸ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
await act(() => setInput('hi!')); // ì…ë ¥ê°’ì„ 'hi!'ë¡œ ë³€ê²½
```

`setInput`ì„ ì‚¬ìš©í•˜ì—¬ ì…ë ¥ê°’ì„ 'hi!'ë¡œ ë³€ê²½í•œë‹¤. ì´ ì—…ë°ì´íŠ¸ëŠ” transitionì„ ì¤‘ë‹¨ì‹œí‚¤ê³ , ìƒˆë¡œìš´ ì—…ë°ì´íŠ¸ë¥¼ ì‹œì‘í•œë‹¤.


```ts
// Once the input has updated, we go back to rendering the transition.
// ì…ë ¥ì´ ì—…ë°ì´íŠ¸ë˜ë©´ ì „í™˜ ë Œë”ë§ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.
if (gate(flags => flags.enableNoCloningMemoCache)) { 
  // We did not have process the first chunk again. We reused the computation from the earlier attempt.
  // ì²« ë²ˆì§¸ ì²­í¬ë¥¼ ë‹¤ì‹œ ì²˜ë¦¬í•  í•„ìš”ê°€ ì—†ì—ˆìŠµë‹ˆë‹¤. ì´ì „ ì‹œë„ì—ì„œ ê³„ì‚°ì„ ì¬ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.
  assertLog(['Suspend! [chunkB]']);
} else {
  // Because we clone/reset the memo cache after every aborted attempt, we must process the first chunk again.
  // ì¤‘ë‹¨ëœ ì‹œë„ë§ˆë‹¤ ë©”ëª¨ ìºì‹œë¥¼ ë³µì œ/ì¬ì„¤ì •í•˜ê¸° ë•Œë¬¸ì— ì²« ë²ˆì§¸ ì²­í¬ë¥¼ ë‹¤ì‹œ ì²˜ë¦¬í•´ì•¼í•©ë‹ˆë‹¤.
  assertLog(['Some expensive processing... [A2]', 'Suspend! [chunkB]']);
}
```

`enableNoCloningMemoCache`ê°€ í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´, ì´ì „ì— ê³„ì‚°ëœ ë°ì´í„°ë¥¼ ì¬ì‚¬ìš©í•˜ê³ , `chunkB`ì— ëŒ€í•œ `useWithLog`ê°€ ì‹¤í–‰ë˜ì–´ 'Suspend! [chunkB]'ê°€ ì°íŒë‹¤.\
í•˜ì§€ë§Œ ë¹„í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´, ì–•ì€ ë³µì‚¬ë¥¼ í†µí•´ ìºì‹œë¥¼ ê´€ë¦¬í•˜ê¸° ë•Œë¬¸ì—, 2ì°¨ì› ë°°ì—´ë¡œ ê´€ë¦¬ë˜ëŠ” memoCacheì˜ ê²½ìš°, `$[0] !== t1`ì´ trueê°€ ë˜ì–´ expensive processê°€ ì‹¤í–‰ëœë‹¤.
```ts
expect(root).toMatchRenderedOutput(
  <>
    <div>Input: hi!</div>
    <div>Data: A1B1</div>
  </>,
);
```

ì—¬ì „íˆ chunkBëŠ” resolveë˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì—, ì´ì „ ë Œë”ë§ ê²°ê³¼ë¥¼ ë³´ì—¬ì¤€ë‹¤.

```ts
await act(() => updatedChunkB.resolve('B2')); // ì²­í¬Bë¥¼ B2ë¡œ resolve
```
`updatedChunkB`ë¥¼ 'B2'ë¡œ resolveí•œë‹¤. ë‹¤ì‹œ ë Œë”ë§ì´ ì¬ê°œëœë‹¤.

```ts
if (gate(flags => flags.enableNoCloningMemoCache)) { 
  // We did not have process the first chunk again. We reused the computation from the earlier attempt.
  // ì²« ë²ˆì§¸ ì²­í¬ë¥¼ ë‹¤ì‹œ ì²˜ë¦¬í•  í•„ìš”ê°€ ì—†ì—ˆìŠµë‹ˆë‹¤. ì´ì „ ì‹œë„ì—ì„œ ê³„ì‚°ì„ ì¬ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.
  assertLog([]);
} else {
  // Because we clone/reset the memo cache after every aborted attempt, we must process the first chunk again.
  // ì¤‘ë‹¨ëœ ì‹œë„ë§ˆë‹¤ ë©”ëª¨ ìºì‹œë¥¼ ë³µì œ/ì¬ì„¤ì •í•˜ê¸° ë•Œë¬¸ì— ì²« ë²ˆì§¸ ì²­í¬ë¥¼ ë‹¤ì‹œ ì²˜ë¦¬í•´ì•¼í•©ë‹ˆë‹¤.
  //
  // That's three total times we've processed the first chunk, compared to just once when enableNoCloningMemoCache is on.
  // enableNoCloningMemoCacheê°€ ì¼œì ¸ ìˆì„ ë•Œ í•œ ë²ˆì— ë¹„í•´ ì„¸ ë²ˆì§¸ ì²­í¬ë¥¼ ì²˜ë¦¬í•œ ì´ íšŸìˆ˜ì…ë‹ˆë‹¤.
  assertLog(['Some expensive processing... [A2]']);
}
expect(root).toMatchRenderedOutput( // ë Œë”ë§ ê²°ê³¼ í™•ì¸
  <>
    <div>Input: hi!</div>
    <div>Data: A2B2</div>
  </>,
);
```
í”Œë˜ê·¸ê°€ í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´, ì´ì „ì— ê³„ì‚°ëœ ë°ì´í„°ë¥¼ ì¬ì‚¬ìš©í•˜ê¸°ì— ë¡œê·¸ ì—†ì´ ë Œë”ë§ì´ ì™„ë£Œëœë‹¤.\
í•˜ì§€ë§Œ ë¹„í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´, ì´ì „ì— ê³„ì‚°ëœ ë°ì´í„°ë¥¼ ì¬ì‚¬ìš©í•˜ì§€ ì•Šê¸°ì— 'Some expensive processing... [A2]'ê°€ ì°íˆê²Œ ëœë‹¤.

ê·¸ë ‡ê²Œ `Data` ì»´í¬ë„ŒíŠ¸ëŠ” `A2B2`ë¥¼ ë°˜í™˜í•˜ê²Œ ëœë‹¤.

ë¹„í™œì„±í™”ë˜ì–´ìˆìœ¼ë©´ ì´ 3ë²ˆì˜ ë¹„ì‹¼ ê³„ì‚°ì´ ì¼ì–´ë‚˜ê²Œ ëœë‹¤.\
í•˜ì§€ë§Œ í™œì„±í™”ë˜ì–´ìˆìœ¼ë©´ 1ë²ˆì˜ ê³„ì‚°ìœ¼ë¡œ ëë‚œë‹¤. ê½¤ë‚˜ í° ì°¨ì´ì´ë‹¤. \
í˜„ì¬ëŠ” falseë¡œ ë˜ì–´ìˆì§€ë§Œ, ì¶”í›„ trueë¡œ ë³€ê²½ëœë‹¤ë©´ í•œì°¨ë¡€ ë” ì„±ëŠ¥ì´ ì¢‹ì•„ì§ˆ ê²ƒì´ë‹¤.

ì ì´ë ‡ê²Œ ì´ì œ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ í†µí•´ì„œ ê¹Œì§€ `useMemoCache`ì˜ ë™ì‘ì„ í™•ì¸í•´ë³´ì•˜ë‹¤.

### ë§ˆì¹˜ë©°

ì´ë²ˆ ê¸€ì—ì„œëŠ” `useMemoCache`ì— ëŒ€í•´ì„œ ì•Œì•„ë³´ì•˜ë‹¤.\
`useMemoCache`ëŠ” ì»´íŒŒì¼ëŸ¬ ë‚´ë¶€ì—ì„œ ì‚¬ìš©ë˜ëŠ” í›…ìœ¼ë¡œ, ë©”ëª¨ì´ì œì´ì…˜ì„ ìœ„í•œ ìºì‹œë¥¼ ê´€ë¦¬í•˜ëŠ” ê²ƒì´ ì£¼ ëª©ì ì´ë‹¤.\
ì•„ì§ ì‹¤í—˜ì ì¸ ê¸°ëŠ¥ì´ì§€ë§Œ ìºì‹œë¥¼ ê³µìœ  í•˜ëŠ” ê¸°ëŠ¥ë„ ì—¼ë‘í•´ ë‘ê³  ìˆëŠ” ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.

ì–´ì œë³´ë‹¤ ë” ì»´íŒŒì¼ëŸ¬ì— ëŒ€í•œ ì‹œì•¼ê°€ ë„“ì–´ì¡Œë‹¤.\
ì´ì œ ê¸°ë³¸ì ìœ¼ë¡œ ì–´ë–¤ ë°©ì‹ì„ í†µí•´ ë©”ëª¨ì´ì œì´ì…˜ì„ êµ¬í˜„í•˜ëŠ”ì§€ ì•Œê²Œ ë˜ì—ˆìœ¼ë‹ˆ, ë‹¤ìŒì—ëŠ” ì‹¤ì§ˆì ìœ¼ë¡œ ì»´íŒŒì¼ëŸ¬ê°€ ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ì§€ì— ëŒ€í•´ ì•Œì•„ë³´ë©´ ì¢‹ì„ ê²ƒ ê°™ë‹¤.

í•­ìƒ ê¸€ì„ ì–´ë–»ê²Œ ë§ˆë¬´ë¦¬ ì§€ì–´ì•¼ í• ì§€ê°€ ê³ ë¯¼ì´ë‹¤. \
ì´ë²ˆì—ë„ ì´ë ‡ê²Œ ê·¸ëƒ¥ ë§ˆë¬´ë¦¬ í•´ë³´ê² ë‹¤. 

ì•ˆë…•!
