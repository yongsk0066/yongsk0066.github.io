---
title: "React Compiler, ë„ˆ ëˆ„êµ¬ë‹ˆ [2] - useMemoCache"
description: "React Compilerì˜ ì£¼ìš” êµ¬ì„± ìš”ì†Œ ì¤‘ í•˜ë‚˜ì¸ useMemoCacheì— ëŒ€í•´ ê¹Šê²Œ ì•Œì•„ë³´ì, useMemoCacheì˜ ë™ì‘ ì›ë¦¬ì™€, êµ¬í˜„ì„ ì‚´í´ë³´ê³ , ì‹¤í—˜ì ì¸ ê¸°ëŠ¥ì¸ enableNoCloningMemoCacheì— ëŒ€í•´ ì•Œì•„ë³´ì."
author: "Yongseok"
categories: ["React Compiler"]
date: '2024-05-26T03:30:51.104Z'
series: "React Compiler"
---
import LinkPreview from '../../components/LinkPreview.astro'
import  { YouTube } from "../../components/lit/youtube-element"


[React Compiler, ë„ˆ ëˆ„êµ¬ë‹ˆ [1]](https://yongsk0066.github.io/blog/react_compiler_1/) ì§€ë‚œ ê¸€ì—ì„œ React Compilerì˜ ì „ì²´ì ì¸ êµ¬ì¡°ë¥¼ ì‚´í´ë³´ì•˜ë‹¤. \
ì»´íŒŒì¼ëŸ¬ì˜ ë™ì‘ ë°©ì‹ì„ ì‚´í´ë³´ê¸°ì „ì—, ë§ì´ ì–¸ê¸‰ë˜ì—ˆë˜ `useMemoCache`ë¥¼ ë¨¼ì € ì‚´í´ë³´ê³  ê°€ì.

ì¼ë‹¨ ì „ì²´ ì½”ë“œë¥¼ ì­‰ í›‘ì–´ ë³´ê³  ë¶€ë¶„ë¶€ë¶„ ì‚´í´ë³´ì

https://github.com/facebook/react/blob/ee5c19493086fdeb32057e16d1e3414370242307/packages/react-reconciler/src/ReactFiberHooks.js#L1116

```ts
// react-reconciler/src/ReactFiberHooks.js
function useMemoCache(size: number): Array<any> {
  let memoCache = null;
  // Fast-path, load memo cache from wip fiber if already prepared
  let updateQueue: FunctionComponentUpdateQueue | null =
    (currentlyRenderingFiber.updateQueue: any);
  if (updateQueue !== null) {
    memoCache = updateQueue.memoCache;
  }
  // Otherwise clone from the current fiber
  if (memoCache == null) {
    const current: Fiber | null = currentlyRenderingFiber.alternate;
    if (current !== null) {
      const currentUpdateQueue: FunctionComponentUpdateQueue | null =
        (current.updateQueue: any);
      if (currentUpdateQueue !== null) {
        const currentMemoCache: ?MemoCache = currentUpdateQueue.memoCache;
        if (currentMemoCache != null) {
          memoCache = {
            // When enableNoCloningMemoCache is enabled, instead of treating the
            // cache as copy-on-write, like we do with fibers, we share the same
            // cache instance across all render attempts, even if the component
            // is interrupted before it commits.
            //
            // If an update is interrupted, either because it suspended or
            // because of another update, we can reuse the memoized computations
            // from the previous attempt. We can do this because the React
            // Compiler performs atomic writes to the memo cache, i.e. it will
            // not record the inputs to a memoization without also recording its
            // output.
            //
            // This gives us a form of "resuming" within components and hooks.
            //
            // This only works when updating a component that already mounted.
            // It has no impact during initial render, because the memo cache is
            // stored on the fiber, and since we have not implemented resuming
            // for fibers, it's always a fresh memo cache, anyway.
            //
            // However, this alone is pretty useful â€” it happens whenever you
            // update the UI with fresh data after a mutation/action, which is
            // extremely common in a Suspense-driven (e.g. RSC or Relay) app.
            data: enableNoCloningMemoCache
              ? currentMemoCache.data
              : // Clone the memo cache before each render (copy-on-write)
                currentMemoCache.data.map(array => array.slice()),
            index: 0,
          };
        }
      }
    }
  }
  // Finally fall back to allocating a fresh instance of the cache
  if (memoCache == null) {
    memoCache = {
      data: [],
      index: 0,
    };
  }
  if (updateQueue === null) {
    updateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = updateQueue;
  }
  updateQueue.memoCache = memoCache;

  let data = memoCache.data[memoCache.index];
  if (data === undefined) {
    data = memoCache.data[memoCache.index] = new Array(size);
    for (let i = 0; i < size; i++) {
      data[i] = REACT_MEMO_CACHE_SENTINEL;
    }
  } else if (data.length !== size) {
    // TODO: consider warning or throwing here
    if (__DEV__) {
      console.error(
        'Expected a constant size argument for each invocation of useMemoCache. ' +
          'The previous cache was allocated with size %s but size %s was requested.',
        data.length,
        size,
      );
    }
  }
  memoCache.index++;
  return data;
}
```

ì´ì œ í•œë²ˆ ìˆœì„œëŒ€ë¡œ í›…ì„ ì‚´í´ë³´ì.

### ë¹ ë¥¸ ê²½ë¡œ

ì²˜ìŒ ì´ë¤„ì§€ëŠ” ì‘ì—…ì€ í˜„ì¬ ë Œë”ë§ ì¤‘ì¸ íŒŒì´ë²„ì˜ `updateQueue`ì—ì„œ `memoCache`ë¥¼ ì°¾ì•„ì˜¤ëŠ” ì‘ì—…ì´ë‹¤.\
ì´ì „ì— í˜¸ì¶œëœ ì (ë Œë”ë§ëœ ì )ì´ ìˆë‹¤ë©´ ì¡´ì¬í•  ê²ƒì´ë‹¤. ì´ë¥¼ í†µí•´ ë¶ˆí•„ìš”í•œ ìºì‹œ í• ë‹¹ì„ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.

```ts
let memoCache = null;
// Fast-path, load memo cache from wip fiber if already prepared
let updateQueue: FunctionComponentUpdateQueue | null =
  (currentlyRenderingFiber.updateQueue: any);
if (updateQueue !== null) {
  memoCache = updateQueue.memoCache;
}
```


### ìºì‹œê°€ ì—†ë‹¤ë©´? ëŒ€ì²´ íŒŒì´ë²„ (Alternate fiber)ì—ì„œ ìºì‹œ ë³µì œ

í˜„ì¬ ë Œë”ë§ ì¤‘ì¸ fiberì˜ `updateQueue`ì— `memoCache`ê°€ ì—†ë‹¤ë©´, ëŒ€ì²´ íŒŒì´ë²„(Alternate fiber)ë¥¼ í™•ì¸í•œë‹¤.\
ëŒ€ì²´ íŒŒì´ë²„ëŠ” ì´ì „ ë Œë”ë§ ê²°ê³¼ë¥¼ ë‚˜íƒ€ë‚´ëŠ” íŒŒì´ë²„ë¡œ, ìºì‹œë¥¼ í¬í•¨í•˜ê³  ìˆì„ ê°€ëŠ¥ì„±ì´ ë†’ë‹¤. \
ëŒ€ì²´ íŒŒì´ë²„ì—ì„œ ìºì‹œë¥¼ ë³µì œí•˜ì—¬ ì‚¬ìš©í•œë‹¤.

ë¡œì§ì˜ íë¦„ì„ ë³´ê¸° ìœ„í•´ ì¡°ê±´ë¬¸ì„ ì ì‹œ ì œê±° í•´ë‘ì—ˆë‹¤. ì›ë¬¸ì€ ìœ„ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

```ts
let memoCache = null;
// ...
// ìºì‹œê°€ ì—†ë‹¤ë©´, ëŒ€ì²´ íŒŒì´ë²„ì—ì„œ ìºì‹œ ë³µì œ
if (memoCache == null) {

  const current = currentlyRenderingFiber.alternate; // ëŒ€ì²´ íŒŒì´ë²„
  const currentUpdateQueue = current.updateQueue;    // ëŒ€ì²´ íŒŒì´ë²„ì˜ updateQueueë¥¼ ê°€ì ¸ì˜¨ë‹¤.
  const currentMemoCache: ?MemoCache = currentUpdateQueue.memoCache; // ëŒ€ì²´ íŒŒì´ë²„ì˜ memoCacheë¥¼ ê°€ì ¸ì˜¨ë‹¤.

  memoCache = {
    data: enableNoCloningMemoCache
      ? currentMemoCache.data
      : // Clone the memo cache before each render (copy-on-write)
        currentMemoCache.data.map(array => array.slice()),
    index: 0,
  };
}
```

ì´ ë•Œ ìºì‹œë¥¼ ë³µì‚¬í•˜ëŠ” ê³¼ì •ì—ì„œ `enableNoCloningMemoCache` ì˜µì…˜ì— ë”°ë¼ ë™ì‘ì´ ë‹¬ë¼ì§„ë‹¤.\
`enableNoCloningMemoCache` í”Œë˜ê·¸ì— ë”°ë¼ ìºì‹œ ë°ì´í„°ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í• ì§€, ê¹Šì€ ë³µì‚¬ë¥¼ í• ì§€ ê²°ì •í•œë‹¤.
- <b>í™œì„±í™”</b>ë˜ì–´ ìˆë‹¤ë©´, ìºì‹œ ë°ì´í„°ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•œë‹¤. ì´ëŠ” ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¤„ì¼ ìˆ˜ ìˆì§€ë§Œ, ìºì‹œ ë°ì´í„°ê°€ ë³€ê²½ë  ë¦¬ìŠ¤í¬ë¥¼ ê°€ì§€ê³  ìˆë‹¤.
- <b>ë¹„í™œì„±í™”</b>ë˜ì–´ ìˆë‹¤ë©´, ìºì‹œ ë°ì´í„°ë¥¼ ì–•ì€ ë³µì‚¬í•˜ì—¬ ì‚¬ìš©í•œë‹¤. ì´ëŠ” ì´ì „ ë Œë”ë§ì˜ ìºì‹œ ë°ì´í„°ë¥¼ ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•´ì£¼ì§€ë§Œ, ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì¦ê°€í•  ìˆ˜ ìˆë‹¤.

<LinkPreview src="https://github.com/facebook/react/pull/28878" />

ì´ë¶€ë¶„ì— ê¸´ ì£¼ì„ì´ ë‹¬ë ¤ìˆëŠ”ë°, ì´ ë‚´ìš©ë„ ì‚´í´ë³´ì. ë²ˆì—­ì„ ë¯¸ë¦¬ í•´ë³´ì•˜ë‹¤.

```plaintext
enableNoCloningMemoCacheê°€ í™œì„±í™”ë˜ë©´, íŒŒì´ë²„ì—ì„œì²˜ëŸ¼ ìºì‹œë¥¼ copy-on-writeë¡œ ì²˜ë¦¬í•˜ì§€ ì•Šê³ , 
ì‹¬ì§€ì–´ ì»´í¬ë„ŒíŠ¸ê°€ ì»¤ë°‹ë˜ê¸° ì „ì— ì¤‘ë‹¨ë˜ë”ë¼ë„ ëª¨ë“  ë Œë”ë§ ì‹œë„ì—ì„œ ëª¨ë‘ ë™ì¼í•œ ìºì‹œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê³µìœ í•©ë‹ˆë‹¤.

ë§Œì•½ ì—…ë°ì´íŠ¸ê°€ ì¤‘ë‹¨ë˜ë©´, ì¼ì‹œ ì¤‘ë‹¨ë˜ì—ˆê¸° ë•Œë¬¸ì´ë“  ë‹¤ë¥¸ ì—…ë°ì´íŠ¸ ë•Œë¬¸ì´ë“ , 
ì´ì „ ì‹œë„ì—ì„œ ë©”ëª¨ëœ ê³„ì‚°ì„ ì¬ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
React ì»´íŒŒì¼ëŸ¬ê°€ ë©”ëª¨ ìºì‹œì— ëŒ€í•´ ì›ìì  ì“°ê¸°ë¥¼ ìˆ˜í–‰í•˜ê¸° ë•Œë¬¸ì— ì´ê²ƒì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. 
ì¦‰, ë©”ëª¨ì´ì œì´ì…˜ì˜ ì¶œë ¥ì„ ê¸°ë¡í•˜ì§€ ì•Šê³ ëŠ” ì…ë ¥ì„ ê¸°ë¡í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ì´ê²ƒì€ ì»´í¬ë„ŒíŠ¸ì™€ í›… ë‚´ì—ì„œ ì¼ì¢…ì˜ "ì¬ê°œ(resuming)" í˜•íƒœë¥¼ ì œê³µí•©ë‹ˆë‹¤.

ì´ê²ƒì€ ì´ë¯¸ ë§ˆìš´íŠ¸ëœ ì»´í¬ë„ŒíŠ¸ë¥¼ ì—…ë°ì´íŠ¸í•  ë•Œë§Œ ì‘ë™í•©ë‹ˆë‹¤. ë©”ëª¨ ìºì‹œê°€ íŒŒì´ë²„ì— ì €ì¥ë˜ê³ , 
íŒŒì´ë²„ì— ëŒ€í•œ ì¬ê°œë¥¼ êµ¬í˜„í•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— ì´ˆê¸° ë Œë”ë§ ë™ì•ˆì—ëŠ” ì˜í–¥ì„ ë¯¸ì¹˜ì§€ ì•ŠìŠµë‹ˆë‹¤. 
ì–´ì¨Œë“  í•­ìƒ ìƒˆë¡œìš´ ë©”ëª¨ ìºì‹œì…ë‹ˆë‹¤.

ê·¸ëŸ¬ë‚˜ ì´ê²ƒë§Œìœ¼ë¡œë„ ê½¤ ìœ ìš©í•©ë‹ˆë‹¤. ë³€ì´/ì•¡ì…˜ í›„ì— ìƒˆë¡œìš´ ë°ì´í„°ë¡œ UIë¥¼ ì—…ë°ì´íŠ¸í•  ë•Œë§ˆë‹¤ ë°œìƒí•˜ëŠ”ë°, 
ì´ëŠ” Suspense ê¸°ë°˜(ì˜ˆ: RSC ë˜ëŠ” Relay)ì˜ ì•±ì—ì„œ ë§¤ìš° ì¼ë°˜ì ì…ë‹ˆë‹¤.
```

`React ì»´íŒŒì¼ëŸ¬ê°€ ë©”ëª¨ ìºì‹œì— ëŒ€í•´ ì›ìì  ì“°ê¸°ë¥¼ ìˆ˜í–‰í•˜ê¸° ë•Œë¬¸ì— ì´ê²ƒì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.  ì¦‰, ë©”ëª¨ì´ì œì´ì…˜ì˜ ì¶œë ¥ì„ ê¸°ë¡í•˜ì§€ ì•Šê³ ëŠ” ì…ë ¥ì„ ê¸°ë¡í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.` ì´ ì˜ë¯¸ëŠ” ë­˜ê¹Œ?
>  ğŸ¤·â€â™‚ï¸ ì›ìê°€ ì—¬ê¸°ì„œ ì™œ ë‚˜ì™€?

ìš°ì„  'ì›ìì (Atomic)' ì´ë¼ëŠ” ë‹¨ì–´ëŠ” 'ë” ì´ìƒ ë‚˜ëˆŒ ìˆ˜ ì—†ëŠ”'ë¼ëŠ” ì˜ë¯¸ë¡œ ì‚¬ìš©ëœë‹¤. (~ì›ìë„ ë‚˜ëˆŒ ìˆ˜ ìˆëŠ”ë°ìš”?~ ë¼ëŠ” ë°œì–¸ì€ í•˜ì§€ë§ì)\
ì»´í“¨í„° ê³¼í•™ì—ì„œì˜ 'ì›ìì  ì‘ì—…(Atomic operation)'ì€ 'ë” ì´ìƒ ë‚˜ëˆŒ ìˆ˜ ì—†ëŠ” ì‘ì—…', ì¦‰ í•œ ë²ˆì— ì™„ì „íˆ ì‹¤í–‰ë˜ê±°ë‚˜ ì‹¤í–‰ë˜ì§€ ì•ŠëŠ” ì‘ì—…ì„ ì˜ë¯¸í•œë‹¤.

<aside>ë‹¤ì¤‘ ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ë§ì´ ì‚¬ìš©ë˜ëŠ” ê°œë…ì´ë‹¤. ë‹¤ì¤‘ ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ê°™ì€ ìì›ì— ì ‘ê·¼í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—,
í•œ ìŠ¤ë ˆë“œê°€ ìì›ì„ ì‚¬ìš©í•˜ëŠ” ë™ì•ˆ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì ‘ê·¼í•˜ì§€ ëª»í•˜ë„ë¡ í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤. ì´ ë•Œ ì‚¬ìš©ë˜ëŠ” ê²ƒì´ 'ì›ìì  ì‘ì—…'ì´ë‹¤.</aside>

<b>ì˜ˆì‹œë¥¼ ë“¤ì–´ë³´ì.</b> \
ì€í–‰ì—ì„œì˜ ê³„ì¢Œì´ì²´ë¥¼ ë– ì˜¬ë ¤ë³´ì. ë§Œì•½ A ê³„ì¢Œì—ì„œ B ê³„ì¢Œë¡œ 10ë§Œì›ì„ ì´ì²´í•œë‹¤ê³  í• ë•Œ ì´ ì‘ì—…ì€ ë‘ë‹¨ê³„ë¡œ ì´ë¤„ì§€ê²Œ ëœë‹¤.
1. A ê³„ì¢Œì—ì„œ 10ë§Œì›ì„ ë¹¼ëŠ” ì‘ì—…
2. B ê³„ì¢Œì— 10ë§Œì›ì„ ë”í•˜ëŠ” ì‘ì—…

ë§Œì•½ ì´ ê³¼ì • ì‚¬ì´ì— ë¬¸ì œê°€ ìƒê²¨ì„œ <b>í”„ë¡œì„¸ìŠ¤ê°€ ì¤‘ë‹¨</b>ëœë‹¤ë©´ ì–´ë–»ê²Œ ë ê¹Œ? \
A ê³„ì¢Œì—ì„œëŠ” 10ë§Œì›ì´ ì‚¬ë¼ì¡Œì§€ë§Œ, B ê³„ì¢ŒëŠ” ë°›ì§€ ëª»í•œ ìƒíƒœê°€ ë˜ì–´ë²„ë¦°ë‹¤. ì´ëŸ° ìƒí™©ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ <b>'ì›ìì  ì‘ì—…'</b>ì´ í•„ìš”í•˜ë‹¤.\
ì¦‰ ì´ì²´ ì‘ì—…ì€ í•œë²ˆì— ì™„ì „íˆ ì‹¤í–‰ë˜ê±°ë‚˜ ì‹¤í–‰ë˜ì§€ ì•Šì•„ì•¼ í•œë‹¤.

React Compilerì˜ ë©”ëª¨ì´ì œì´ì…˜ ê³¼ì •ë„ ì´ì™€ ë¹„ìŠ·í•œ ê°œë…ì„ ì‚¬ìš©í•œë‹¤. ì˜ˆì‹œë¥¼ í†µí•´ì„œ ì„¤ëª…í•´ë³´ì.

ì•„ë˜ ì½”ë“œë¥¼ ì»´íŒŒì¼ í•´ë³´ì.

```tsx
function Component({ active }) {
  let color: string;
  if (active) {
    color = "red";
  } else {
    color = "blue";
  }
  return <div styles={{ color }}>hello world</div>;
}
```

ì»´íŒŒì¼ í•˜ê²Œë˜ë©´ ì•„ë˜ì™€ ê°™ì´ ë³€í™˜ëœë‹¤.
  
```tsx
function Component(t0) {
  const $ = _c(2);

  const { active } = t0;
  let color;

  if (active) {
    color = "red";
  } else {
    color = "blue";
  }

  let t1;

  if ($[0] !== color) {
    t1 = (
      <div styles={{ color }}>hello world</div>
    );
    $[0] = color;
    $[1] = t1;
  } else {
    t1 = $[1];
  }

  return t1;
}
```

ì—¬ë¦¬ì„œ ìš°ë¦¬ê°€ ì£¼ëª©í•´ì•¼í•  ë¶€ë¶„ì€ ì´ë¶€ë¶„ì´ë‹¤.

```ts
if ($[0] !== color) {
  t1 = (
    <div styles={{ color }}>hello world</div>
  );
  $[0] = color;
  $[1] = t1;
} else {
  t1 = $[1];
}
```
ë¨¼ì € ê°„ë‹¨íˆ ë™ì‘ì„ ì„¤ëª…í•´ë³´ì.
`$`ëŠ” memoCacheë¥¼ ì˜ë¯¸í•œë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” `$[0]`ì—ëŠ” ì´ì „ì— ì €ì¥ëœ color ê°’ì„ ì €ì¥í•˜ê³ , `$[1]`ì—ëŠ” ì´ì „ì— ë Œë”ë§ëœ ê²°ê³¼ë¥¼ ì €ì¥í•˜ê³  ìˆë‹¤.\
`if ($[0] !== color)` ìºì‹œëœ colorê°’ê³¼ í˜„ì¬ colorê°’ì„ ë¹„êµí•œë‹¤. ë§Œì•½ ë‹¤ë¥´ë‹¤ë©´, ìƒˆë¡œìš´ colorì— ëŒ€í•œ ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ìƒì„±í•´ì•¼í•œë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤.\
ì´ë•Œ ìƒˆë¡œìš´ ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ìƒì„±í•˜ê³ , `$[0]`ì— ìƒˆë¡œìš´ colorê°’ì„ ì €ì¥í•˜ê³ , `$[1]`ì— ìƒˆë¡œìš´ ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ì €ì¥í•œë‹¤.\
ê·¸ë ‡ì§€ ì•Šë‹¤ë©´, ì´ì „ì— ë Œë”ë§ëœ ê²°ê³¼ë¥¼ ì‚¬ìš©í•œë‹¤.

ì—¬ê¸°ì„œ ì¤‘ìš”í•œ ì ì€ `$[0] = color;`ì™€ `$[1] = t1;`ì´ ê°™ì€ ë¸”ë¡ ë‚´ì—ì„œ ì—°ì†ì ìœ¼ë¡œ ì¼ì–´ë‚œë‹¤ëŠ” ê²ƒì´ë‹¤.\
ì´ê²ƒì´ ë°”ë¡œ <b>'ì›ìì  ì“°ê¸°'</b>ì´ë‹¤.

ì´ ë‘ ì¤„ì€ í•˜ë‚˜ì˜ ì›ìì  ì—°ì‚°ìœ¼ë¡œ ì²˜ë¦¬ë˜ê¸°ì—, color ê°’ì´ ìºì‹œì— ì“°ì´ë©´, ê·¸ì— í•´ë‹¹í•˜ëŠ” ì—˜ë¦¬ë¨¼íŠ¸ë„ ë°˜ë“œì‹œ ìºì‹œì— ì“°ì¸ë‹¤. ì´ë“¤ ì‚¬ì´ì˜ ì¤‘ê°„ ìƒíƒœëŠ” ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤.\
ì´ì œ React Compilerì˜ ì›ìì  ì“°ê¸°ê°€ ë¬´ì—‡ì„ ì˜ë¯¸í•˜ëŠ”ì§€ ì•Œê²Œ ë˜ì—ˆë‹¤.

ë‹¤ì‹œ ë³¸ë˜ ë‚´ìš©ìœ¼ë¡œ ëŒì•„ê°€ ë³´ì.\
`enableNoCloningMemoCache`ê°€ false ë¼ë©´ ê° ë Œë”ë§ ì‹œë„ì‹œ ì´ì „ ë Œë”ë§ì˜ ìºì‹œë¥¼ ë³µì‚¬í•˜ê³  ì´ ë³µì‚¬ë³¸ì„ ìˆ˜ì •í•˜ëŠ” ì‹ìœ¼ë¡œ (copy-on-write) ì‚¬ìš©í•œë‹¤.\
í•˜ì§€ë§Œ ì´ ë°©ë²•ì€ ë Œë”ë§ì´ ì¤‘ë‹¨ë˜ê³  ì¬ê°œë  ë•Œë§ˆë‹¤ ìºì‹œë¥¼ ë³µì‚¬í•˜ë¯€ë¡œ, ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì¦ê°€í•  ìˆ˜ ìˆë‹¤.

`enableNoCloningMemoCache`ê°€ trueë¼ë©´ ëª¨ë“  ë Œë”ë§ ì‹œë„ì—ì„œ ë™ì¼í•œ ìºì‹œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê³µìœ í•œë‹¤.

ì¦‰, ë Œë”ë§ì´ ì¤‘ë‹¨(suspended/interrupted)ë˜ê³  ì¬ê°œ ë˜ë”ë¼ë„, ì´ì „ ë Œë”ë§ ì‹œë„ì—ì„œì˜ ìºì‹œë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.\
ì´ëŠ” ë©”ëª¨ë¦¬ ê´€ë¦¬ì— ìˆì–´ì„œ í° ì´ì ì´ë‹¤. 

ì´ëŸ° ë™ì‘ì´ ê°€ëŠ¥í•˜ë ¤ë©´ React ì»´íŒŒì¼ëŸ¬ê°€ ë©”ëª¨ ìºì‹œì— ëŒ€í•´ ì›ìì  ì“°ê¸°ë¥¼ ìˆ˜í–‰í•´ì•¼ í•œë‹¤ëŠ” ê²ƒì´ë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ë³´ì¥ë˜ì§€ ì•Šì•˜ë‹¤ë©´, ì•„ë˜ì™€ ê°™ì€ ë¬¸ì œê°€ ë°œìƒí–ˆì„ ê²ƒì´ë‹¤.

1. 'A'ë Œë”ë§ ì‹œë„ê°€ color ê°’ì„ 'red'ë¡œ ìºì‹œì— ì €ì¥í•œë‹¤.
2. ê·¸ëŸ¬ë‚˜ ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ìºì‹œì— ê¸°ë¡í•˜ê¸° ì „ì—, ë Œë”ë§ì´ ì¤‘ë‹¨ë˜ì–´ë²„ë¦°ë‹¤.
3. 'B'ë Œë”ë§ ì‹œë„ê°€ ì‹œì‘ë˜ë©´, ì´ë•Œ ìºì‹œì—ëŠ” colorì— ëŒ€í•œ ì…ë ¥ì€ ìˆì§€ë§Œ, ì¶œë ¥ì´ ì—†ëŠ” ìƒíƒœê°€ ëœë‹¤.

ì´ëŠ” ìºì‹œ ë¶ˆì¼ì¹˜ ë¬¸ì œë¥¼ ë°œìƒì‹œí‚¤ê³  ì´ëŠ” ë Œë”ë§ ê²°ê³¼ì˜ ë¶ˆì¼ì¹˜ë¡œ ì´ì–´ì§ˆ ê²ƒì´ë‹¤. \
ìƒíƒœì— ë”°ë¥¸ ë Œë”ë§ ë¶ˆì¼ì¹˜ ë¬¸ì œ... ì–´ë””ì„œ ë“¤ì–´ë³¸ì ì´ ìˆì§€ ì•Šë‚˜ìš”? 'useSyncExternalStore'ë¥¼ ì„¤ëª…í•  ë•Œ ë‚˜ì˜¤ëŠ” tearing ë¬¸ì œì™€ ë¹„ìŠ·í•˜ë‹¤.

<LinkPreview src="https://github.com/reactwg/react-18/discussions/69"/>

í•˜ì§€ë§Œ 'ì›ìì  ì“°ê¸°'ê°€ ë³´ì¥ëœë‹¤ë©´, colorì— ëŒ€í•œ ìºì‹œê°€ ìˆë‹¤ëŠ” ê²ƒì€ ë°˜ë“œì‹œ ì—˜ë¦¬ë¨¼íŠ¸ì— ëŒ€í•œ ìºì‹œë„ ìˆë‹¤ëŠ” ê²ƒì„ ë³´ì¥ ë°›ì„ ìˆ˜ ìˆë‹¤.

<LinkPreview src="https://github.com/facebook/react/pull/25143" />

`useMemoCache`ì— ëŒ€í•œ ì´ˆê¸° êµ¬í˜„ PRì´ë‹¤. 


íœ´, ë­”ê°€ ê½¤ë‚˜ ë©€ë¦¬ ì™”ë‹¤. ì´ì œ ë‹¤ì‹œ `useMemoCache`ë¡œ ëŒì•„ê°€ë³´ì.

`enableNoCloningMemoCache`ì¡°ê±´ì— ë”°ë¥¸ ë¶„ê¸°ë¥¼ ë³´ë‹¤ê°€ ì—¬ê¸°ê¹Œì§€ ì™”ë‹¤.
ê·¸ë˜ì„œ `enableNoCloningMemoCache`ëŠ” ì°¸ì´ëƒ ê±°ì§“ì´ëƒ!

```ts
// react/shared/ReactFeatureFlags.js

// Test this at Meta before enabling.
export const enableNoCloningMemoCache = false;
```
í˜„ ì‹œì ì—ì„œëŠ” `enableNoCloningMemoCache`ëŠ” falseë¡œ ì„¤ì •ë˜ì–´ ìˆë‹¤.

### ìºì‹œê°€ ì—†ë‹¤ë©´? ìƒˆë¡œìš´ ìºì‹œ ìƒì„±

ì´ì œ ë§ˆì§€ë§‰ìœ¼ë¡œ ìºì‹œê°€ ì—†ë‹¤ë©´, ìƒˆë¡œìš´ ìºì‹œë¥¼ ìƒì„±í•œë‹¤.

```ts
if (memoCache == null) {
  memoCache = {
    data: [],
    index: 0,
  };
}
```

### ìºì‹œ í• ë‹¹

updateQueueê°€ ì—†ë‹¤ë©´ ìƒˆë¡œ ë§Œë“¤ê³ , memoCacheë¥¼ í• ë‹¹í•œë‹¤.

```ts
if (updateQueue === null) {
  updateQueue = createFunctionComponentUpdateQueue();
  currentlyRenderingFiber.updateQueue = updateQueue;
}
updateQueue.memoCache = memoCache;
```

`createFunctionComponentUpdateQueue`ëŠ” ê¸°ë³¸ì ì¸ queueê°ì²´ë¥¼ return í•œë‹¤. 
enableUseMemoCacheHook í”Œë˜ê·¸ì— ë”°ë¼ ë‚˜ë‰˜ëŠ”ë° í˜„ì¬ëŠ” trueë˜ì–´ìˆë‹¤.

```ts
// NOTE: defining two versions of this function to avoid size impact when this feature is disabled.
// Previously this function was inlined, the additional `memoCache` property makes it not inlined.
// ë©”ëª¨ : ì´ ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆì„ ë•Œ í¬ê¸° ì˜í–¥ì„ í”¼í•˜ê¸° ìœ„í•´ ì´ í•¨ìˆ˜ì˜ ë‘ ê°€ì§€ ë²„ì „ì„ ì •ì˜í•©ë‹ˆë‹¤.
// ì´ì „ì— ì´ í•¨ìˆ˜ëŠ” ì¸ë¼ì¸ìœ¼ë¡œ ì •ì˜ë˜ì—ˆìœ¼ë©°, ì¶”ê°€ì ì¸ `memoCache` ì†ì„±ìœ¼ë¡œ ì¸í•´ ì¸ë¼ì¸ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
let createFunctionComponentUpdateQueue: () => FunctionComponentUpdateQueue;
if (enableUseMemoCacheHook) {
  createFunctionComponentUpdateQueue = () => {
    return {
      lastEffect: null,
      events: null,
      stores: null,
      memoCache: null,
    };
  };
} else {
  createFunctionComponentUpdateQueue = () => {
    return {
      lastEffect: null,
      events: null,
      stores: null,
    };
  };
}
```

### ìºì‹œ ë°ì´í„° ë°˜í™˜

ë§ˆì§€ë§‰ìœ¼ë¡œ ìºì‹œ ë°ì´í„°ë¥¼ ë°˜í™˜í•œë‹¤.

ìºìƒˆë¡œ ë¶€í„° ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ê³ ,

```ts
let data = memoCache.data[memoCache.index]; 
```

ë°ì´í„°ê°€ ì—†ë‹¤ë©´ ìƒˆë¡œìš´ ë°ì´í„°ë¥¼ í• ë‹¹í•˜ê³ , `REACT_MEMO_CACHE_SENTINEL`ë¡œ ì´ˆê¸°í™”í•œë‹¤.\
`REACT_MEMO_CACHE_SENTINEL`ì€ memoizationì´ ë˜ì§€ ì•Šì€ ìƒíƒœë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.\
í˜¸ì¶œ ë³„ë¡œ ìºì‹œëŠ” Arrayí˜•íƒœë¡œ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì— Arrayë¡œ ì´ˆê¸°í™”í•œë‹¤.

```ts
if (data === undefined) { 
  data = memoCache.data[memoCache.index] = new Array(size);
  for (let i = 0; i < size; i++) {
    data[i] = REACT_MEMO_CACHE_SENTINEL;
  }
}
```

ë§Œì•½ dataê°€ `undefined`ê°€ ì•„ë‹ˆë¼ë©´, ì¦‰ ìºì‹œ ë°ì´í„°ê°€ ì¡´ì¬í•œë‹¤ë©´, dataì˜ ê¸¸ì´ê°€ ìš”ì²­ëœ sizeì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤.\
í™•ì¸í•˜ëŠ” ì´ìœ ëŠ”, ì´ì „ ë Œë”ë§ì—ì„œ ì‚¬ìš©ëœ ìºì‹œ ë°ì´í„°ì™€ í˜„ì¬ ë Œë”ë§ì—ì„œ ì‚¬ìš©í•  ìºì‹œ ë°ì´í„°ì˜ ê¸¸ì´ê°€ ë‹¤ë¥´ë‹¤ë©´, ê²½ê³ ë¥¼ ë„ìš´ë‹¤.

```ts
else if (data.length !== size) {
  if (__DEV__) {
    console.error(
      'useMemoCacheì˜ ê° í˜¸ì¶œì— ëŒ€í•´ ìƒìˆ˜ í¬ê¸° ì¸ìˆ˜ê°€ ì˜ˆìƒë©ë‹ˆë‹¤.' +
        'ì´ì „ ìºì‹œëŠ” í¬ê¸° %së¡œ í• ë‹¹ë˜ì—ˆì§€ë§Œ í¬ê¸° %sê°€ ìš”ì²­ë˜ì—ˆìŠµë‹ˆë‹¤.',
      data.length,
      size,
    );
  }
}
```

ë§ˆì§€ë§‰ìœ¼ë¡œ ìºì‹œ ì¸ë±ìŠ¤ë¥¼ ì¦ê°€ì‹œí‚¤ê³  ë°ì´í„°ë¥¼ ë°˜í™˜í•œë‹¤.

```ts
memoCache.index++;
return data;
```

ì´ì „ í¸ì—ì„œ ì‚´í´ë´¤ë˜ 'react-compiler-runtime'ì—ì„œì˜ êµ¬í˜„ê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ, ì¡°ê¸ˆë” Fiberì— ë§ê²Œ ìˆ˜ì •ëœ ë¶€ë¶„ì´ ìˆë‹¤.

### `useMemo`ì™€ `useMemoCache` ì°¨ì´

ìš°ë¦¬ì—ê² ìµìˆ™í•œ, ê·¸ë¦¬ê³  ì´ì œ ìŠí˜€ì§€ê²Œ ë  `useMemo`. ì´ë¦„ë„ ë¹„ìŠ·í•œ íƒ“ì— ì°¨ì´ì— ëŒ€í•œ ì˜ë¬¸ì„ ê°€ì§ˆ ìˆ˜ ìˆì„ ê²ƒì´ë‹¤.

ê°„ë‹¨í•˜ê²Œ `useMemo`ì˜ êµ¬í˜„ì„ ëŒì•„ë³´ì.

```ts
function mountMemo<T>(
  nextCreate: () => T,
  deps: Array<mixed> | void | null,
): T {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function updateMemo<T>(
  nextCreate: () => T,
  deps: Array<mixed> | void | null,
): T {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps; //
  const prevState = hook.memoizedState;
  if (prevState !== null) {
    // Assume these are defined. If they're not, areHookInputsEqual will warn.
    if (nextDeps !== null) {
      const prevDeps: Array<mixed> | null = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) { // ì´ì „ depsì™€ í˜„ì¬ depsê°€ ê°™ë‹¤ë©´ ì´ì „ ê°’ì„ ë°˜í™˜
        return prevState[0];
      }
    }
  }
  const nextValue = nextCreate(); // ìƒˆë¡œìš´ ê°’ ìƒì„±
  hook.memoizedState = [nextValue, nextDeps]; // ìƒˆë¡œìš´ ê°’ê³¼ depsë¥¼ ì €ì¥
  return nextValue; // ìƒˆë¡œìš´ ê°’ ë°˜í™˜
}
```

ë‘˜ë‹¤ ë©”ëª¨ì´ì œì´ì…˜ì„ ìœ„í•œ í›…ì´ì§€ë§Œ ì¡°ê¸ˆ ë‹¤ë¥´ë‹¤, `useMemo`ëŠ” ê°œë°œìê°€ ì§ì ‘ì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” í›…ìœ¼ë¡œ, ì˜ì¡´ì„± ë°°ì—´ì„ ë°›ì•„ì„œ ì˜ì¡´ì„±ì´ ë³€ê²½ë˜ì—ˆì„ ë•Œë§Œ ìƒˆë¡œìš´ ê°’ì„ ìƒì„±í•œë‹¤.\
`useMemo`ëŠ” ì˜ì¡´ì„± ë°°ì—´ì„ í†µí•´ ë©”ëª¨ì´ì œì´ì…˜ ì—¬ë¶€ë¥¼ í›…ì´ ì±…ì„ì§€ëŠ” ê²ƒì´ë‹¤.\
ë°˜ë©´ `useMemoCache`ëŠ” ì»´íŒŒì¼ëŸ¬ ë‚´ë¶€ì—ì„œ ì‚¬ìš©í•˜ëŠ” í›…ìœ¼ë¡œ, ì˜ì¡´ì„± ë°°ì—´ì„ ë°›ì§€ ì•Šê³ , ìºì‹œë¥¼ ê´€ë¦¬í•˜ëŠ” ê²ƒì´ ì£¼ ëª©ì ì´ë‹¤.\
ê·¸ë ‡ê¸° ë©”ëª¨ì´ì œì´ì…˜ì˜ ì±…ì„ì€ `useMemoCache`ê°€ ì•„ë‹Œ ì»´íŒŒì¼ëŸ¬ê°€ ë§¡ëŠ”ë‹¤.

### `useMemoCache`ì˜ í…ŒìŠ¤íŠ¸ ì½”ë“œ

```ts
// ë¹„ì‹¼ ê³„ì‚°ì„ í•˜ëŠ” í•¨ìˆ˜
function someExpensiveProcessing(t) { 
  Scheduler.log(`Some expensive processing... [${t}]`);
  return t;
}

// ì„œìŠ¤íŒ¬ìŠ¤ë¥¼ íŠ¸ë¦¬ê±° í•˜ê¸°ìœ„í•œ í•¨ìˆ˜
function useWithLog(t, msg) { 
  try {
    return React.use(t); 
  } catch (x) {
    Scheduler.log(`Suspend! [${msg}]`);
    throw x;
  }
}

function Data({chunkA, chunkB}) { 
  const a = someExpensiveProcessing(useWithLog(chunkA, 'chunkA')); 
  const b = useWithLog(chunkB, 'chunkB');
  return (
    <>
      {a}
      {b}
    </>
  );
}

function Input() {
  const [input, _setText] = useState('');
  return input;
}

function App({chunkA, chunkB}) {
  return (
    <>
      <div>
        Input: <Input />
      </div>
      <div>
        Data: <Data chunkA={chunkA} chunkB={chunkB} />
      </div>
    </>
  );
}
```
ì´ì™€ ê°™ì€ í˜•íƒœì˜ ì»´í¬ë„ŒíŠ¸ë“¤ì˜ ì»´íŒŒì¼ ê²°ê³¼ë¬¼ì„ ê°€ì§€ê³  í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰í•´ë³´ì.\
Data ì»´í¬ë„ŒíŠ¸ëŠ” chunkAì™€ chunkBë¥¼ ë°›ì•„ì™€ì„œ, chunkAì— ëŒ€í•œ ë¹„ì‹¼ ê³„ì‚°ì„ ìˆ˜í–‰í•˜ê³ , chunkBëŠ” ê·¸ëŒ€ë¡œ ë°˜í™˜í•œë‹¤.

```ts
// react-reconciler/src/__tests__/useMemoCache-test.js
test('ì—…ë°ì´íŠ¸ ì¤‘ì— ì¤‘ë‹¨ëœ(suspended/interrupted) ë Œë”ë§ ì‹œë„ì—ì„œì˜ ê³„ì‚°ì„ ì¬ì‚¬ìš©í•©ë‹ˆë‹¤', async () => { 
  // This test demonstrates the benefit of a shared memo cache. By "shared" I
  // mean multiple concurrent render attempts of the same component/hook use
  // the same cache. (When the feature flag is off, we don't do this â€” the
  // cache is copy-on-write.)
  // ì´ í…ŒìŠ¤íŠ¸ëŠ” ê³µìœ  ë©”ëª¨ ìºì‹œì˜ ì´ì ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. "ê³µìœ "ë¼ëŠ” ë§ì€ ë™ì¼í•œ ì»´í¬ë„ŒíŠ¸/í›…ì˜
  // ì—¬ëŸ¬ ë™ì‹œ ë Œë”ë§ ì‹œë„ê°€ ë™ì¼í•œ ìºì‹œë¥¼ ì‚¬ìš©í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. 
  // (ê¸°ëŠ¥ í”Œë˜ê·¸ê°€ êº¼ì ¸ ìˆìœ¼ë©´ ì´ë ‡ê²Œ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ - ìºì‹œëŠ” ë³µì‚¬ë³¸ì…ë‹ˆë‹¤.)


  function Data(t0) {
    const $ = useMemoCache(5);
    const {chunkA, chunkB} = t0;
    const t1 = useWithLog(chunkA, 'chunkA');
    let t2;

    if ($[0] !== t1) {
      t2 = someExpensiveProcessing(t1);
      $[0] = t1;
      $[1] = t2;
    } else {
      t2 = $[1];
    }

    const a = t2;
    const b = useWithLog(chunkB, 'chunkB');
    let t3;

    if ($[2] !== a || $[3] !== b) {
      t3 = (
        <>
          {a}
          {b}
        </>
      );
      $[2] = a;
      $[3] = b;
      $[4] = t3;
    } else {
      t3 = $[4];
    }

    return t3;
  }

  let setInput;
  function Input() {
    const [input, _set] = useState('');
    setInput = _set;
    return input;
  }

  function App(t0) {
    const $ = useMemoCache(4);
    const {chunkA, chunkB} = t0;
    let t1;

    if ($[0] === Symbol.for('react.memo_cache_sentinel')) {
      t1 = (
        <div>
          Input: <Input />
        </div>
      );
      $[0] = t1;
    } else {
      t1 = $[0];
    }

    let t2;

    if ($[1] !== chunkA || $[2] !== chunkB) {
      t2 = (
        <>
          {t1}
          <div>
            Data: <Data chunkA={chunkA} chunkB={chunkB} />
          </div>
        </>
      );
      $[1] = chunkA;
      $[2] = chunkB;
      $[3] = t2;
    } else {
      t2 = $[3];
    }

    return t2;
  }

  // Resolved í”„ë¡œë¯¸ìŠ¤ ìƒì„±
  function createInstrumentedResolvedPromise(value) {
    return {
      then() {},
      status: 'fulfilled',
      value,
    };
  }

  // Pending í”„ë¡œë¯¸ìŠ¤ ìƒì„±
  function createDeferred() { 
    let resolve;  
    const p = new Promise(res => { 
      resolve = res;
    });
    p.resolve = resolve;
    return p;  
  }
```

ì»´íŒŒì¼ëœ ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì´ì œ í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰í•´ë³´ì.


#### ì²« ë²ˆì§¸ ë Œë”ë§

ìµœì´ˆ ë Œë”ë§ì—ì„œëŠ” `chunkA`ì™€ `chunkB`ë¥¼ ë°›ì•„ì™€ì„œ `Data` ì»´í¬ë„ŒíŠ¸ë¥¼ ë Œë”ë§í•œë‹¤.\
`createInstrumentedResolvedPromise`ëŠ” Resolvedëœ í”„ë¡œë¯¸ìŠ¤ë¥¼ ìƒì„±í•œë‹¤. ì¦‰ ì´ë¯¸ ë°›ì•„ì˜¨ ë°ì´í„°ë¥¼ ì˜ë¯¸í•œë‹¤. \
ì´ë•ŒëŠ” A1ì— ê±¸ë ¤ìˆëŠ” expensive processì— ëŒ€í•œ ë¡œê·¸ê°€ ì°íˆê³ , `Data` ì»´í¬ë„ŒíŠ¸ëŠ” `A1B1`ì„ ë°˜í™˜í•œë‹¤.


```ts
// Initial render. We pass the data in as two separate "chunks" to simulate a stream (e.g. RSC).
// ìµœì´ˆ ë Œë”ë§. ë°ì´í„°ë¥¼ ë‘ ê°œì˜ ë³„ë„ "ì²­í¬"ë¡œ ì „ë‹¬í•˜ì—¬ ìŠ¤íŠ¸ë¦¼(ì˜ˆ: RSC)ì„ ì‹œë®¬ë ˆì´ì…˜í•©ë‹ˆë‹¤.
const root = ReactNoop.createRoot();
const initialChunkA = createInstrumentedResolvedPromise('A1'); // A1ë¡œ resolveëœ í”„ë¡œë¯¸ìŠ¤ ìƒì„±
const initialChunkB = createInstrumentedResolvedPromise('B1'); // B1ë¡œ resolveëœ í”„ë¡œë¯¸ìŠ¤ ìƒì„±
await act(() => 
  root.render(<App chunkA={initialChunkA} chunkB={initialChunkB} />), // ì´ˆê¸° ë Œë”ë§
);
assertLog(['Some expensive processing... [A1]']); // 
expect(root).toMatchRenderedOutput(
  <>
    <div>Input: </div>
    <div>Data: A1B1</div>
  </>,
);
```

#### ì „í™˜ì¤‘ì— UI ì—…ë°ì´íŠ¸

```ts
const updatedChunkA = createDeferred(); 
const updatedChunkB = createDeferred(); 
```

`createDeferred` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ `updatedChunkA`ì™€ `updatedChunkB`ë¼ëŠ” ë‘ ê°œì˜ Promise ê°ì²´ë¥¼ ìƒì„±í•œë‹¤. ì´ ê°ì²´ë“¤ì€ ë‚˜ì¤‘ì— ë°ì´í„°ë¥¼ ë¡œë“œí•˜ëŠ” ë° ì‚¬ìš©ëœë‹¤

```ts
await act(() => {
  React.startTransition(() => {
    root.render(<App chunkA={updatedChunkA} chunkB={updatedChunkB} />);
  });
});
```

`React.startTransition`ì„ ì‚¬ìš©í•˜ì—¬ UI ì—…ë°ì´íŠ¸ë¥¼ ì‹œì‘í•œë‹¤. transitionì€ ë‚®ì€ ìš°ì„ ìˆœìœ„ë¡œ ìŠ¤ì¼€ì¤„ë§ë˜ì–´, ë‹¤ë¥¸ ì‘ì—…ì´ ëë‚œ í›„ì— ì‹¤í–‰ëœë‹¤.\
ì´ë•Œ `App` ì»´í¬ë„ŒíŠ¸ì— `updatedChunkA`ì™€ `updatedChunkB`ë¥¼ ì „ë‹¬í•˜ì—¬ ë Œë”ë§í•œë‹¤.

```ts
assertLog(['Suspend! [chunkA]']); 
```
```ts
  const t1 = useWithLog(chunkA, 'chunkA');
```
`useWithLog` í•¨ìˆ˜ì—ì„œ `chunkA`ì— ëŒ€í•œ `useWithLog`ê°€ ì‹¤í–‰ë˜ê³ , pending ì¤‘ì— ìˆìŒìœ¼ë¡œ `use`ì— ì˜í•´ì„œ Suspenseê°€ íŠ¸ë¦¬ê±° ë˜ê³  'Suspend! [chunkA]'ê°€ ì°íˆê²Œ ëœë‹¤.

```ts
await act(() => updatedChunkA.resolve('A2'));
```
`updatedChunkA`ë¥¼ 'A2'ë¡œ resolveí•œë‹¤.

```ts
const t1 = useWithLog(chunkA, 'chunkA');
let t2;

if ($[0] !== t1) {
  t2 = someExpensiveProcessing(t1);
  $[0] = t1;
  $[1] = t2;
} else {
  t2 = $[1];
}
const a = t2;
const b = useWithLog(chunkB, 'chunkB');

```
ë°ì´í„°ê°€ ì¤€ë¹„ë˜ì—ˆìœ¼ë¯€ë¡œ, ë Œë”ë§ì´ ì¬ê°œ ë˜ê³ , `useWithLog`ê°€ ì‹¤í–‰ëœë‹¤.\
ì´ë•Œ `t1`ì€ 'A2'ê°€ ë˜ê³ , `$[0]`ì—ëŠ” ì´ì „ì— ì €ì¥ëœ 'A1'ê³¼ ë¹„êµí•˜ì—¬ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— expensive processê°€ ì‹¤í–‰ëœë‹¤.\
ê·¸ì— ë”°ë¼ 'Some expensive processing... [A2]'ê°€ ì°íˆê²Œ ëœë‹¤.

ë°”ë¡œ ë‹¤ìŒìœ¼ë¡œ `useWithLog`ê°€ ì‹¤í–‰ë˜ê³ , chunkBëŠ” ì•„ì§ resolveë˜ì§€ ì•Šì•˜ê¸°ì— 'Suspend! [chunkB]'ê°€ ì°íˆê²Œ ëœë‹¤.\
ë‹¤ì‹œ ë Œë”ë§ì´ ì¤‘ë‹¨ë˜ì—ˆê¸° ë•Œë¬¸ì—, ì´ˆê¸° UIë¥¼ ê·¸ëŒ€ë¡œ ë³´ì—¬ì¤€ë‹¤.

```ts
expect(root).toMatchRenderedOutput(
  <>
    <div>Input: </div>
    <div>Data: A1B1</div>
  </>,
);
```


#### ì—…ë°ì´íŠ¸ ì „í™˜ ì¤‘ ë‹¤ë¥¸ ë¶€ë¶„ ì—…ë°ì´íŠ¸

```ts
// While waiting for the data to finish loading, update a different part of the screen. This interrupts the refresh transition.
// ë°ì´í„° ë¡œë“œê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” ë™ì•ˆ í™”ë©´ì˜ ë‹¤ë¥¸ ë¶€ë¶„ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤. ì´ëŠ” ìƒˆë¡œ ê³ ì¹¨ ì „í™˜ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.
//
// In a real app, this might be an input or hover event.
// ì‹¤ì œ ì•±ì—ì„œëŠ” ì…ë ¥ ë˜ëŠ” í˜¸ë²„ ì´ë²¤íŠ¸ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
await act(() => setInput('hi!')); // ì…ë ¥ê°’ì„ 'hi!'ë¡œ ë³€ê²½
```

`setInput`ì„ ì‚¬ìš©í•˜ì—¬ ì…ë ¥ê°’ì„ 'hi!'ë¡œ ë³€ê²½í•œë‹¤. ì´ ì—…ë°ì´íŠ¸ëŠ” transitionì„ ì¤‘ë‹¨ì‹œí‚¤ê³ , ìƒˆë¡œìš´ ì—…ë°ì´íŠ¸ë¥¼ ì‹œì‘í•œë‹¤.


```ts
// Once the input has updated, we go back to rendering the transition.
// ì…ë ¥ì´ ì—…ë°ì´íŠ¸ë˜ë©´ ì „í™˜ ë Œë”ë§ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.
if (gate(flags => flags.enableNoCloningMemoCache)) { 
  // We did not have process the first chunk again. We reused the computation from the earlier attempt.
  // ì²« ë²ˆì§¸ ì²­í¬ë¥¼ ë‹¤ì‹œ ì²˜ë¦¬í•  í•„ìš”ê°€ ì—†ì—ˆìŠµë‹ˆë‹¤. ì´ì „ ì‹œë„ì—ì„œ ê³„ì‚°ì„ ì¬ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.
  assertLog(['Suspend! [chunkB]']);
} else {
  // Because we clone/reset the memo cache after every aborted attempt, we must process the first chunk again.
  // ì¤‘ë‹¨ëœ ì‹œë„ë§ˆë‹¤ ë©”ëª¨ ìºì‹œë¥¼ ë³µì œ/ì¬ì„¤ì •í•˜ê¸° ë•Œë¬¸ì— ì²« ë²ˆì§¸ ì²­í¬ë¥¼ ë‹¤ì‹œ ì²˜ë¦¬í•´ì•¼í•©ë‹ˆë‹¤.
  assertLog(['Some expensive processing... [A2]', 'Suspend! [chunkB]']);
}
```

`enableNoCloningMemoCache`ê°€ í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´, ì´ì „ì— ê³„ì‚°ëœ ë°ì´í„°ë¥¼ ì¬ì‚¬ìš©í•˜ê³ , `chunkB`ì— ëŒ€í•œ `useWithLog`ê°€ ì‹¤í–‰ë˜ì–´ 'Suspend! [chunkB]'ê°€ ì°íŒë‹¤.\
í•˜ì§€ë§Œ ë¹„í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´, ì–•ì€ ë³µì‚¬ë¥¼ í†µí•´ ìºì‹œë¥¼ ê´€ë¦¬í•˜ê¸° ë•Œë¬¸ì—, 2ì°¨ì› ë°°ì—´ë¡œ ê´€ë¦¬ë˜ëŠ” memoCacheì˜ ê²½ìš°, `$[0] !== t1`ì´ trueê°€ ë˜ì–´ expensive processê°€ ì‹¤í–‰ëœë‹¤.
```ts
expect(root).toMatchRenderedOutput(
  <>
    <div>Input: hi!</div>
    <div>Data: A1B1</div>
  </>,
);
```

ì—¬ì „íˆ chunkBëŠ” resolveë˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì—, ì´ì „ ë Œë”ë§ ê²°ê³¼ë¥¼ ë³´ì—¬ì¤€ë‹¤.

```ts
await act(() => updatedChunkB.resolve('B2')); // ì²­í¬Bë¥¼ B2ë¡œ resolve
```
`updatedChunkB`ë¥¼ 'B2'ë¡œ resolveí•œë‹¤. ë‹¤ì‹œ ë Œë”ë§ì´ ì¬ê°œëœë‹¤.

```ts
if (gate(flags => flags.enableNoCloningMemoCache)) { 
  // We did not have process the first chunk again. We reused the computation from the earlier attempt.
  // ì²« ë²ˆì§¸ ì²­í¬ë¥¼ ë‹¤ì‹œ ì²˜ë¦¬í•  í•„ìš”ê°€ ì—†ì—ˆìŠµë‹ˆë‹¤. ì´ì „ ì‹œë„ì—ì„œ ê³„ì‚°ì„ ì¬ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.
  assertLog([]);
} else {
  // Because we clone/reset the memo cache after every aborted attempt, we must process the first chunk again.
  // ì¤‘ë‹¨ëœ ì‹œë„ë§ˆë‹¤ ë©”ëª¨ ìºì‹œë¥¼ ë³µì œ/ì¬ì„¤ì •í•˜ê¸° ë•Œë¬¸ì— ì²« ë²ˆì§¸ ì²­í¬ë¥¼ ë‹¤ì‹œ ì²˜ë¦¬í•´ì•¼í•©ë‹ˆë‹¤.
  //
  // That's three total times we've processed the first chunk, compared to just once when enableNoCloningMemoCache is on.
  // enableNoCloningMemoCacheê°€ ì¼œì ¸ ìˆì„ ë•Œ í•œ ë²ˆì— ë¹„í•´ ì„¸ ë²ˆì§¸ ì²­í¬ë¥¼ ì²˜ë¦¬í•œ ì´ íšŸìˆ˜ì…ë‹ˆë‹¤.
  assertLog(['Some expensive processing... [A2]']);
}
expect(root).toMatchRenderedOutput( // ë Œë”ë§ ê²°ê³¼ í™•ì¸
  <>
    <div>Input: hi!</div>
    <div>Data: A2B2</div>
  </>,
);
```
í”Œë˜ê·¸ê°€ í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´, ì´ì „ì— ê³„ì‚°ëœ ë°ì´í„°ë¥¼ ì¬ì‚¬ìš©í•˜ê¸°ì— ë¡œê·¸ ì—†ì´ ë Œë”ë§ì´ ì™„ë£Œëœë‹¤.\
í•˜ì§€ë§Œ ë¹„í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´, ì´ì „ì— ê³„ì‚°ëœ ë°ì´í„°ë¥¼ ì¬ì‚¬ìš©í•˜ì§€ ì•Šê¸°ì— 'Some expensive processing... [A2]'ê°€ ì°íˆê²Œ ëœë‹¤.

ì ì´ë ‡ê²Œ ì´ì œ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ í†µí•´ì„œ ê¹Œì§€ `useMemoCache`ì˜ ë™ì‘ì„ í™•ì¸í•´ë³´ì•˜ë‹¤.

### ë§ˆì¹˜ë©°

ì´ë²ˆ ê¸€ì—ì„œëŠ” `useMemoCache`ì— ëŒ€í•´ì„œ ì•Œì•„ë³´ì•˜ë‹¤.\
`useMemoCache`ëŠ” ì»´íŒŒì¼ëŸ¬ ë‚´ë¶€ì—ì„œ ì‚¬ìš©ë˜ëŠ” í›…ìœ¼ë¡œ, ë©”ëª¨ì´ì œì´ì…˜ì„ ìœ„í•œ ìºì‹œë¥¼ ê´€ë¦¬í•˜ëŠ” ê²ƒì´ ì£¼ ëª©ì ì´ë‹¤.\
ì•„ì§ ì‹¤í—˜ì ì¸ ê¸°ëŠ¥ì´ì§€ë§Œ ìºì‹œë¥¼ ê³µìœ  í•˜ëŠ” ê¸°ëŠ¥ë„ ì—¼ë‘í•´ ë‘ê³  ìˆëŠ” ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.

ì–´ì œë³´ë‹¤ ë” ì»´íŒŒì¼ëŸ¬ì— ëŒ€í•œ ì‹œì•¼ê°€ ë„“ì–´ì¡Œë‹¤.\
ì´ì œ ê¸°ë³¸ì ìœ¼ë¡œ ì–´ë–¤ ë°©ì‹ì„ í†µí•´ ë©”ëª¨ì´ì œì´ì…˜ì„ êµ¬í˜„í•˜ëŠ”ì§€ ì•Œê²Œ ë˜ì—ˆìœ¼ë‹ˆ, ë‹¤ìŒì—ëŠ” ì‹¤ì§ˆì ìœ¼ë¡œ ì»´íŒŒì¼ëŸ¬ê°€ ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ì§€ì— ëŒ€í•´ ì•Œì•„ë³´ë©´ ì¢‹ì„ ê²ƒ ê°™ë‹¤.

í•­ìƒ ê¸€ì„ ì–´ë–»ê²Œ ë§ˆë¬´ë¦¬ ì§€ì–´ì•¼ í• ì§€ê°€ ê³ ë¯¼ì´ë‹¤. \
ì´ë²ˆì—ë„ ì´ë ‡ê²Œ ê·¸ëƒ¥ ë§ˆë¬´ë¦¬ í•´ë³´ê² ë‹¤. 

ì•ˆë…•!
