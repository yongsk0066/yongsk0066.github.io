---
title: React Compiler, ì–´ë–»ê²Œ ë™ì‘í• ê¹Œ [3] - HIRë¡œ ë³€í™˜ (Lowering)
description: "React Compilerì˜ Lowering ê³¼ì •ì„ ì‚´í´ë³´ì. ASTë¥¼ HIRë¡œ ë³€í™˜í•˜ëŠ” ê³¼ì •ì´ë‹¤."
author: "Yongseok"
categories: ["React Compiler"]
date: '2024-06-10T15:10:03.760Z'
series: "React Compiler"
---
import LinkPreview from '@components/LinkPreview.astro'
import  { YouTube } from "@components/lit/youtube-element"

## ì´ì „ì´ì•¼ê¸°

ì§€ë‚œ ë‘í¸ì„ í†µí•´ **ì»´íŒŒì¼ëŸ¬ì˜ ì§„ì…ì **ê³¼ ìºì‹±ë°©ë²•ì¸ **useMemoCache**ì— ëŒ€í•´ì„œ ì•Œì•„ë³´ì•˜ë‹¤. 
ì´ë²ˆ ë¶€í„°ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ì–´ë–¤ ê³¼ì •ë“¤ì„ í†µí•´ì„œ **êµ¬ë¬¸ ë¶„ì„**ì„ í•˜ê³  **ì»´íŒŒì¼**ì„ í•˜ëŠ”ì§€ ì•Œì•„ë³´ë„ë¡ í•˜ì.

1í¸ì—ì„œ ì‚´í´ë´¤ë˜ ì‹¤ì§ˆì ìœ¼ë¡œ ì»´íŒŒì¼ì„ ì§„í–‰í•˜ëŠ” í•¨ìˆ˜ì¸ `compileFn`ì„ ë‹¤ì‹œ ì‚´í´ë³´ì.

```ts
export function compileFn(
  func: NodePath<
    t.FunctionDeclaration | t.ArrowFunctionExpression | t.FunctionExpression
  >,
  config: EnvironmentConfig,
  fnType: ReactFunctionType,
  useMemoCacheIdentifier: string,
  logger: Logger | null,
  filename: string | null,
  code: string | null
): CodegenFunction {
  let generator = run(
    func,
    config,
    fnType,
    useMemoCacheIdentifier,
    logger,
    filename,
    code
  );
  while (true) {
    const next = generator.next();
    if (next.done) {
      return next.value;
    }
  }
}
```

`compileFn` í•¨ìˆ˜ëŠ” `run` í•¨ìˆ˜ë¥¼ í†µí•´ ì½”ë“œë¥¼ ìƒì„±í•˜ê³ , `generator.next()`ë¥¼ í†µí•´ ì½”ë“œë¥¼ ìƒì„±í•˜ëŠ” ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.

```ts
// packages/babel-plugin-react-compiler/src/Entrypoint/Pipline.ts
export type CompilerPipelineValue =
  | { kind: "ast"; name: string; value: CodegenFunction }
  | { kind: "hir"; name: string; value: HIRFunction }
  | { kind: "reactive"; name: string; value: ReactiveFunction }
  | { kind: "debug"; name: string; value: string };

export function* run(
  func: NodePath<
    t.FunctionDeclaration | t.ArrowFunctionExpression | t.FunctionExpression
  >,
  config: EnvironmentConfig,
  fnType: ReactFunctionType,
  useMemoCacheIdentifier: string,
  logger: Logger | null,
  filename: string | null,
  code: string | null
): Generator<CompilerPipelineValue, CodegenFunction> {
  const contextIdentifiers = findContextIdentifiers(func);
  const env = new Environment(
    fnType,
    config,
    contextIdentifiers,
    logger,
    filename,
    code,
    useMemoCacheIdentifier
  );
  yield {
    kind: "debug",
    name: "EnvironmentConfig",
    value: prettyFormat(env.config),
  };
  const ast = yield* runWithEnvironment(func, env);
  return ast;
}

```

`run` í•¨ìˆ˜ëŠ” `Environment`ë¥¼ ìƒì„±í•˜ê³ , `runWithEnvironment` í•¨ìˆ˜ë¥¼ í†µí•´ ì½”ë“œë¥¼ ìƒì„±í•œë‹¤.\
`Environment`ëŠ” ì»´íŒŒì¼ ê³¼ì •ì—ì„œ ì „ì—­ì ì¸ ìƒíƒœì™€ ì„¤ì •ì„ ê´€ë¦¬í•˜ëŠ” ê°ì²´ì´ë‹¤. 
ì´ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ ë‹¤ìŒì— ì‚´í´ë³´ë„ë¡ í•˜ê³ , ì¼ë‹¨ ë„˜ì–´ê°€ì.

ì´ì œ `runWithEnvironment` í•¨ìˆ˜ë¥¼ ì‚´í´ë³´ì.\
ì‹¤ì§ˆì ìœ¼ë¡œ ì½”ë“œë¥¼ ìƒì„±í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.

## runWithEnvironment

```ts
// packages/babel-plugin-react-compiler/src/Entrypoint/Pipline.ts
function* runWithEnvironment(
  func: NodePath<
    t.FunctionDeclaration | t.ArrowFunctionExpression | t.FunctionExpression
  >,
  env: Environment
): Generator<CompilerPipelineValue, CodegenFunction> {
  const hir = lower(func, env).unwrap();
  yield log({ kind: "hir", name: "HIR", value: hir });

  pruneMaybeThrows(hir);
  yield log({ kind: "hir", name: "PruneMaybeThrows", value: hir });

  validateContextVariableLValues(hir);
  validateUseMemo(hir);

  dropManualMemoization(hir);
  yield log({ kind: "hir", name: "DropManualMemoization", value: hir });

  // ~~~~~~~~~~~~~~~~~~~~~
  // --- ì¤‘ê°„ ì—¬ëŸ¬ ê³¼ì •ë“¤ ---
  // ~~~~~~~~~~~~~~~~~~~~~

  const ast = codegenFunction(reactiveFunction, uniqueIdentifiers).unwrap();
  yield log({ kind: "ast", name: "Codegen", value: ast });

  /**
   * This flag should be only set for unit / fixture tests to check
   * that Forget correctly handles unexpected errors (e.g. exceptions
   * thrown by babel functions or other unexpected exceptions).
   */
  if (env.config.throwUnknownException__testonly) {
    throw new Error("unexpected error");
  }

  // ìµœì¢…ì ìœ¼ë¡œ ìƒì„±ëœ ì½”ë“œë¥¼ ë°˜í™˜
  return ast;
}
```

ì „ì²´ ê³¼ì •ì€ ì•½ 40ê°œ ì •ë„ì˜ ê³¼ì •ì„ ê±°ì¹˜ë©° ì½”ë“œë¥¼ ìƒì„±í•œë‹¤.\
ê° ê³¼ì •ì„ì„ ìš°ì„  í¬ê²Œ ë¶„ë¥˜í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

1. <b>'Lowering'</b>: ASTë¥¼ HIR(High-level Intermediate Representation)ë¡œ ë³€í™˜
2. <b>'Normalization, Optimization'</b> : HIRì„ ì •ê·œí™”í•˜ê³  ìµœì í™”í•˜ëŠ” ê³¼ì •
3. <b>'Static Analysis, Type Inference'</b> : SSA í˜•íƒœë¡œ ë³€í™˜í•˜ê³  íƒ€ì… ì¶”ë¡ 
4. <b>'Reactive Optimization'</b> : ë°˜ì‘ì„± ìµœì í™”
5. <b>'Code Generation'</b> : ì½”ë“œ ìƒì„±

ë” ì„¸ë¶€ì ìœ¼ë¡œ í¼ì³ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.\
ì•„ì§ ê¹Šê²Œ ë“¤ì—¬ë‹¤ë³´ì§„ ë§ê³  ì–´ë–¤ ê³¼ì •ë“¤ì´ ìˆëŠ”ì§€ë§Œ í›‘ì–´ë³´ì.

1. <b>'Lowering'</b>
    - `lower`: ASTë¥¼ HIRë¡œ ë³€í™˜
2. <b>'ìµœì í™” ë° ì •ê·œí™”'</b>
    - `pruneMaybeThrows`: HIRì—ì„œ `MaybeThrows`ë¥¼ ì œê±°
    - `validateContextVariableLValues`: HIRì—ì„œ Context ë³€ìˆ˜ì˜ LValuesë¥¼ ê²€ì¦
    - `validateUseMemo`: HIRì—ì„œ `useMemo`ë¥¼ ê²€ì¦
    - `dropManualMemoization`: ìˆ˜ë™ìœ¼ë¡œ ë©”ëª¨ì´ì œì´ì…˜ì„ ì œê±°
    - `inlineImmediatelyInvokedFunctionExpressions`: ì¦‰ì‹œ í˜¸ì¶œ í•¨ìˆ˜ í‘œí˜„ì‹(IIFE)ì„ ì¸ë¼ì¸í™”
    - `mergeConsecutiveBlocks`: ì—°ì†ëœ ë¸”ë¡ì„ ë³‘í•©
3. <b>'ì •ì  ë¶„ì„ ë° íƒ€ì… ì¶”ë¡ '</b>
    - `enterSSA`: SSA(Static Single Assignment) í˜•íƒœë¡œ ë³€í™˜
    - `eliminateRedundantPhi`: ì¤‘ë³µëœ Phi ë…¸ë“œ ì œê±°
    - `constantPropagation`: ìƒìˆ˜ ì „íŒŒ
    - `inferTypes`: íƒ€ì… ì¶”ë¡ 
    - `validateHooksUsage`: í›… ì‚¬ìš©ì˜ ìœ íš¨ì„± ê²€ì‚¬
    - `validateNoCapitalizedCalls`: ëŒ€ë¬¸ìë¡œ ì‹œì‘í•˜ëŠ” í•¨ìˆ˜ í˜¸ì¶œ ê²€ì‚¬
    - `analyseFunctions`: í•¨ìˆ˜ ë¶„ì„
    - `inferReferenceEffects`: ì°¸ì¡° íš¨ê³¼ ì¶”ë¡ 
    - `deadCodeElimination`: ë°ë“œ ì½”ë“œ ì œê±°
    - `inferMutableRanges`: ê°€ë³€ ë²”ìœ„ ì¶”ë¡ 
    - `inferReactivePlaces`: ë°˜ì‘í˜• ì¥ì†Œ ì¶”ë¡ 
    - `leaveSSA`: SSAí˜•íƒœì—ì„œ ì¼ë°˜ì ì¸ í˜•íƒœë¡œ ë³µê·€
4. <b>'ë°˜ì‘í˜• ìµœì í™”(HIR)'</b>
    - `inferReactiveScopeVariables`: ë°˜ì‘í˜• ìŠ¤ì½”í”„ ë³€ìˆ˜ ì¶”ë¡ 
    - `alignMethodCallScopes`: ë©”ì„œë“œ í˜¸ì¶œ ìŠ¤ì½”í”„ ì •ë ¬
    - `alignObjectMethodScopes`: ê°ì²´ ë©”ì„œë“œ ìŠ¤ì½”í”„ ì •ë ¬
    - `memoizeFbtOperandsInSameScope`: ë™ì¼í•œ ìŠ¤ì½”í”„ ë‚´ Fbt í”¼ì—°ì‚°ì ë©”ëª¨ì´ì œì´ì…˜
    - `pruneUnusedLabelsHIR`: ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë ˆì´ë¸” ì œê±°
    - `alignReactiveScopesToBlockScopesHIR`: ë°˜ì‘í˜• ìŠ¤ì½”í”„ë¥¼ ë¸”ë¡ ìŠ¤ì½”í”„ì— ì •ë ¬
    - `mergeOverlappingReactiveScopesHIR`: ê²¹ì¹˜ëŠ” ë°˜ì‘í˜• ìŠ¤ì½”í”„ ë³‘í•©
    - `buildReactiveScopeTerminalsHIR`: ë°˜ì‘í˜• ìŠ¤ì½”í”„ ë‹¨ë§ ìƒì„±
    - `buildReactiveFunction`: ë°˜ì‘í˜• í•¨ìˆ˜ ìƒì„±
5. <b>'ë°˜ì‘í˜• ìµœì í™” (Reactive function)'</b>
    - `pruneUnusedLabels`: ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë ˆì´ë¸” ì œê±°
    - `flattenReactiveLoops`: ë°˜ì‘í˜• ë£¨í”„ í‰íƒ„í™”
    - `propagateScopeDependencies`: ìŠ¤ì½”í”„ ì˜ì¡´ì„± ì „íŒŒ
    - `pruneNonReactiveDependencies`: ë¹„ë°˜ì‘í˜• ì˜ì¡´ì„± ì œê±°
    - `pruneUnusedScopes`: ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ìŠ¤ì½”í”„ ì œê±°
    - `mergeReactiveScopesThatInvalidateTogether`: í•¨ê»˜ ë¬´íš¨í™”ë˜ëŠ” ë°˜ì‘í˜• ìŠ¤ì½”í”„ ë³‘í•©
    - `pruneAlwaysInvalidatingScopes`: í•­ìƒ ë¬´íš¨í™”ë˜ëŠ” ìŠ¤ì½”í”„ ì œê±°
    - `propagateEarlyReturns`: ì¡°ê¸° ë°˜í™˜ ì „íŒŒ
    - `promoteUsedTemporaries`: ì‚¬ìš©ëœ ì„ì‹œ ë³€ìˆ˜ í”„ë¡œëª¨ì…˜
    - `pruneUnusedLValues`: ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” LValue ì œê±°
    - `extractScopeDeclarationsFromDestructuring`: í•´ì²´ì—ì„œ ìŠ¤ì½”í”„ ì„ ì–¸ ì¶”ì¶œ
    - `stabilizeBlockIds`: ë¸”ë¡ ID ì•ˆì •í™”
    - `renameVariables`: ë³€ìˆ˜ ì´ë¦„ ë³€ê²½
    - `pruneHoistedContexts`: í˜¸ì´ìŠ¤íŒ…ëœ ì»¨í…ìŠ¤íŠ¸ ì œê±°
5. <b>'Code Generation'</b>
    - `codegenFunction`: ìµœì¢… ì½”ë“œ ìƒì„±

ê³¼ì •ë“¤ì„ ë‹¤ ì‚´í´ë³¼ì§€ëŠ” ëª¨ë¥´ê² ì§€ë§Œ, ìš°ì„  ì‹œì‘í•´ë³´ì.

## Lowering

```ts
const hir = lower(func, env).unwrap();
```

ë¦¬ì•¡íŠ¸ ì»´íŒŒì¼ëŸ¬ì˜ ì²« ë²ˆì§¸ ë‹¨ê³„ì¸ **Lowering**ì€ **AST**(Abstract Syntax Tree)ë¥¼ **HIR**(High-level Intermediate Representation)ë¡œ ë³€í™˜í•˜ëŠ” ê³¼ì •ì´ë‹¤.

ë¨¼ì € **ì»´íŒŒì¼**ì— ëŒ€í•´ ë‹¤ì‹œ ì§‘ê³  ë„˜ì–´ê°€ë³´ì.
> to collect information from different places and arrange it in a book, report, or list \
[\[Cambridge Dictionary\]](https://dictionary.cambridge.org/dictionary/english/compile)

ì‚¬ì „ì  ì˜ë¯¸ë¡œëŠ” ë‹¤ì–‘í•œ ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ì—¬ ì±…, ë³´ê³ ì„œ ë˜ëŠ” ëª©ë¡ìœ¼ë¡œ ì •ë¦¬í•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.\
**ì»´í“¨í„° ê³¼í•™**ì—ì„œ ì»´íŒŒì¼ì€ **ì†ŒìŠ¤ ì½”ë“œ**ë¥¼ **ê¸°ê³„ì–´**ë¡œ ë³€í™˜í•˜ëŠ” ê³¼ì •ì„ ì˜ë¯¸í•œë‹¤.

ê¸°ê³„ì–´ë¡œ ë°”ê¾¼ë‹¤. ì‰½ê²Œ ë§í•´, **ì»´í“¨í„°ê°€ ì´í•´í•  ìˆ˜ ìˆëŠ” ì–¸ì–´ë¡œ ë°”ê¾¼ë‹¤**ëŠ” ê²ƒì´ë‹¤.
<figure><img src="/post/images/ReactCompiler3/Compiler.png" />
<figcaption>ì»´íŒŒì¼ëŸ¬</figcaption>
</figure>

<aside>
<b>Compiler or Transpiler?</b>\
React Conf 2024ì—ì„œ React Compilerê°€ ê³µê°œëœ ì´í›„ ë§ì€ ë…¼ìŸì´ ìˆì—ˆëŠ”ë°, React Compilerê°€ ì»´íŒŒì¼ëŸ¬ëƒ íŠ¸ëœìŠ¤íŒŒì¼ëŸ¬ëƒì— ëŒ€í•œ ê²ƒì´ì—ˆë‹¤.\
ì»´íŒŒì¼ëŸ¬ëŠ” ìœ„ì—ì„œ ì‚´í´ë³¸ ê²ƒ ì²˜ëŸ¼ ê³ ìˆ˜ì¤€ì—ì„œ ì €ìˆ˜ì¤€ìœ¼ë¡œì˜ ë‹¨ë°©í–¥ì„± ë³€í™˜ì„ í•˜ëŠ” ê²ƒìœ¼ë¡œ ì•Œë ¤ì ¸ìˆëŠ”ë°, React Compilerì˜ ê²°ê³¼ë¬¼ì€ ìµœì í™”ëœ React ì½”ë“œì´ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ëŸ¬ë¼ê³ 
ë¶€ë¥´ê¸° ì–´ë µì§€ ì•ŠëƒëŠ” ê²ƒì´ë‹¤. ì´ ë…¼ìŸì€ ê´€ì‹¬ ìˆìœ¼ë©´ ë” ì°¾ì•„ë³´ê¸°ë¡œ í•˜ì.
</aside>

**ì†ŒìŠ¤ì½”ë“œ**ì—ì„œ ë°”ë²¨ì— ì˜í•´ **AST**ë¡œ ë³€í™˜ë˜ì—ˆê³  ì´ ASTë¥¼ í•œë‹¨ê³„ ë” ë‚®ì¶° **ì¤‘ê°„í‘œí˜„**(IR)ìœ¼ë¡œ ë³€í™˜ í•˜ì˜€ê¸°ì— **Lowering**ì´ë¼ê³  ë¶€ë¥¸ë‹¤.

ê·¸ëŸ¼ HIRë¡œ ë°”ê¿”ì£¼ëŠ” `lower` í•¨ìˆ˜ë¥¼ ì‚´í´ë³´ì.

```ts
// packages/babel-plugin-react-compiler/src/HIR/BuildHIR.ts

 /* 
  * í•¨ìˆ˜ë¥¼ ì œì–´ íë¦„ ê·¸ë˜í”„(Control-Flow Graph, CFG)ë¡œ ë‚˜íƒ€ë‚´ëŠ” ê³ ìˆ˜ì¤€ ì¤‘ê°„ í˜•íƒœ(HIR)ë¡œ ë³€í™˜í•©ë‹ˆë‹¤. 
  * ëª¨ë“  ì •ìƒ ì œì–´ íë¦„ì€ ì •í™•í•˜ê²Œ ëª¨ë¸ë§ë˜ì–´ ì •í™•í•œ í‘œí˜„ìˆ˜ì¤€(expression-level)ì˜ ë©”ëª¨ì´ì œì´ì…˜ì„ í—ˆìš©í•©ë‹ˆë‹¤. 
  * ì£¼ìš” ì˜ˆì™¸ëŠ” try/catch ë¬¸ê³¼ ì˜ˆì™¸ì…ë‹ˆë‹¤. 
  * í˜„ì¬ try/catchë¥¼ ìœ„í•´ ì»´íŒŒì¼ì„ ê±´ë„ˆë›°ê³  ì˜ˆì™¸ì˜ ì œì–´ íë¦„ì„ ëª¨ë¸ë§í•˜ë ¤ê³  ì‹œë„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. 
  * ì´ëŠ” JavaScriptì˜ ì–´ë””ì—ì„œë‚˜ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì˜ˆì™¸ì…ë‹ˆë‹¤. 
  * ì»´íŒŒì¼ëŸ¬ëŠ” ì˜ˆì™¸ê°€ ëŸ°íƒ€ì„ì— ì˜í•´ ì²˜ë¦¬ë  ê²ƒìœ¼ë¡œ ê°€ì •í•˜ë©°, 
  * ì¦‰ ë©”ëª¨ì´ì œì´ì…˜ì„ ë¬´íš¨í™”í•¨ìœ¼ë¡œì¨ ì²˜ë¦¬ë  ê²ƒìœ¼ë¡œ ê°€ì •í•©ë‹ˆë‹¤.
  */
export function lower(
  func: NodePath<t.Function>,
  env: Environment,
  bindings: Bindings | null = null,
  capturedRefs: Array<t.Identifier> = [],
  // ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œë˜ëŠ” ê²½ìš°(ëŒë‹¤ í•¨ìˆ˜ì˜ ê²½ìš°) lower()ë¥¼ í˜¸ì¶œí•˜ëŠ” ê°€ì¥ ë°”ê¹¥ìª½ í•¨ìˆ˜
  parent: NodePath<t.Function> | null = null
): Result<HIRFunction, CompilerError> {
// ...
}
```
í•¨ìˆ˜ ìœ„ì˜ ì£¼ì„ì„ ì°¸ê³ í•´ë³´ë©´, **AST**(Abstract Syntax Tree)ë¥¼ **CFG**(Control-Flow Graph ì´í•˜ CFG)ë¡œ ë‚˜íƒ€ë‚´ëŠ” **ê³ ìˆ˜ì¤€ ì¤‘ê°„ í‘œí˜„**(HIR)ë¡œ ë³€í™˜í•œë‹¤ê³  í•œë‹¤.

**AST**ëŠ” **êµ¬ë¬¸ íŠ¸ë¦¬**ë¡œ, í”„ë¡œê·¸ë¨ì˜ êµ¬ë¬¸ì„ ë‚˜íƒ€ë‚´ëŠ” íŠ¸ë¦¬ í˜•íƒœì˜ ìë£Œêµ¬ì¡°ì¸ ë°˜ë©´, **CFG**ëŠ” **ì œì–´ íë¦„ ê·¸ë˜í”„**ë¡œ, í”„ë¡œê·¸ë¨ì˜ ì œì–´ íë¦„ì„ ë‚˜íƒ€ë‚´ëŠ” ê·¸ë˜í”„ í˜•íƒœì˜ ìë£Œêµ¬ì¡°ì´ë‹¤.\
ê·¸ë˜í”„ì˜ ê° ë…¸ë“œëŠ” **ê¸°ë³¸ ë¸”ë¡**(Basic Block)ì´ë¼ê³  í•˜ëŠ” ì½”ë“œì˜ ì—°ì†ì ì¸ ë¶€ë¶„ì„ ë‚˜íƒ€ë‚´ë©°, **ì—£ì§€**(edge)ëŠ” í•œ ê¸°ë³¸ ë¸”ë¡ì—ì„œ ë‹¤ë¥¸ ê¸°ë³¸ ë¸”ë¡ìœ¼ë¡œì˜ ì œì–´ íë¦„ì„ ë‚˜íƒ€ ë‚¸ë‹¤.\
ì œì–´ íë¦„ êµ¬ì¡°ë€, if/else, switch, loopì™€ ê°™ì€ ë¶„ê¸°ì™€ ë°˜ë³µì„ ì˜ë¯¸í•œë‹¤.
**CFG**ëŠ” í”„ë¡œê·¸ë¨ì˜ ëª¨ë“  ê°€ëŠ¥í•œ ì‹¤í–‰ ê²½ë¡œë¥¼ í¬ì°©í•˜ì—¬ ì½”ë“œ ìµœì í™”ì™€ ë¶„ì„ì— ì‚¬ìš©ëœë‹¤.
<figure><img src="/post/images/ReactCompiler3/ast_hir.png" />
<figcaption>AST & HIR</figcaption>
</figure>

ê·¸ë¦¼ì€ ì´ë ‡ê²Œ ê·¸ë ¸ì§€ë§Œ ê° ë…¸ë“œëŠ” ì„œë¡œ ë§¤ì¹­ë˜ì§€ ì•ŠëŠ”ë‹¤.\
ì´í•´ë¥¼ ë•ê¸° ìœ„í•´ ê²°ê³¼ë¬¼ì„ ë¨¼ì € ì‚´í´ë³´ì. \
ë‹¤ìŒì€ ê°„ë‹¨í•œ ì½”ë“œë¥¼ ASTì™€ HIRë¡œ ë³€í™˜í•œ ê²°ê³¼ë¬¼ì´ë‹¤.

```tsx
function Component({ color }: { color: string }) {
  if (color === "red") {
    return (<div styles={{ color }}>hello red</div>)
  } else {
    return (<div styles={{ color }}>hello etc</div>)
  }
}
```
ì´í•´ë¥¼ ë•ê¸°ìœ„í•œ ì˜ˆì œ ì½”ë“œì´ë‹¤. `Component` í•¨ìˆ˜ëŠ” `color`ê°€ `red`ì¼ ë•Œì™€ ì•„ë‹ ë•Œë¥¼ ë‚˜ëˆ„ì–´ ë‹¤ë¥¸ JSXë¥¼ ë°˜í™˜í•œë‹¤.
ì´ ì½”ë“œë¥¼ ASTë¡œ ë‚˜íƒ€ë‚´ë©´ ë‹¤ìŒê³¼ ê°™ì€ êµ¬ë¬¸ì— ëŒ€í•œ íŠ¸ë¦¬ë¡œ í‘œí˜„ ë  ê²ƒì´ë‹¤.
```ts
// Component í•¨ìˆ˜
FunctionDeclaration
  Identifier
  Parameter
    ObjectBindingPattern
      BindingElement
        Identifier
    TypeLiteral
  Block
    IfStatement
      BinaryExpression
        Identifier
        EqualsEqualsEqualsToken
        StringLiteral
      Block
        ReturnStatement
          ParenthesizedExpression
            JsxElement
              JsxOpeningElement
                Identifier
                //...
//...
```
ê·¸ë˜í”„ë¡œ í‘œí˜„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.
<figure><img src="/post/images/ReactCompiler3/ast.png" />
<figcaption>AST ê·¸ë˜í”„ (ê°„ëµ)</figcaption>
</figure>


ì´ì œ ì´ ASTë¥¼ HIRë¡œ ë³€í™˜í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì´ ë‚˜ì˜¨ë‹¤.
```plaintext
function Component
bb0 (block):
  [1] <unknown> $2 = Destructure Let { color: <unknown> color$1 } = <unknown> $0
  [2] <unknown> $11 = LoadLocal <unknown> color$1
  [3] <unknown> $12 = "red"
  [4] <unknown> $13 = Binary <unknown> $11 === <unknown> $12
  [5] If (<unknown> $13) then:bb2 else:bb4 fallthrough=bb1
bb2 (block):
  predecessor blocks: bb0
  [6] <unknown> $3 = LoadLocal <unknown> color$1
  [7] <unknown> $4 = Object { color: <unknown> $3 }
  [8] <unknown> $5 = JSXText "hello red"
  [9] <unknown> $6 = JSX <div styles={<unknown> $4} >{<unknown> $5}</div>
  [10] Return <unknown> $6
bb4 (block):
  predecessor blocks: bb0
  [11] <unknown> $7 = LoadLocal <unknown> color$1
  [12] <unknown> $8 = Object { color: <unknown> $7 }
  [13] <unknown> $9 = JSXText "hello etc"
  [14] <unknown> $10 = JSX <div styles={<unknown> $8} >{<unknown> $9}</div>
  [15] Return <unknown> $10
bb1 (block):
  [16] Unreachable
```
ì—¬ê¸°ì„œ ì½”ë“œë¥¼ ì´í•´í•˜ì§€ ì•Šì•„ë„ ê´œì°®ë‹¤. í›‘ì–´ë§Œ ë³´ì.\
ì´ ì˜ˆì œ ì½”ë“œì—ì„œì˜ ì œì–´íë¦„ì€ `Component` í•¨ìˆ˜ ë‚´ì˜ `if`ë¬¸ì´ë‹¤. ê·¸ì— ë”°ë¼ `Component` í•¨ìˆ˜ëŠ”  **bb0**, **bb2**, **bb4** ê·¸ë¦¬ê³  **bb1** ë„¤ ê°œì˜ ê¸°ë³¸ ë¸”ëŸ­ìœ¼ë¡œ ë‚˜ë‰˜ì—ˆë‹¤.
```ts
  [5] If (<unknown> $13) then:bb2 else:bb4 fallthrough=bb1
```
ì´ ë¶€ë¶„ì„ ë³´ë©´ `If`ë¬¸ì„ í†µí•´ `bb2`ë¡œ ê°€ëŠ” ê²½ìš°ì™€ `bb4`ë¡œ ê°€ëŠ” ê²½ìš°, ê·¸ë¦¬ê³  `fallthrough`ë¡œ `bb1`ë¡œ ê°€ëŠ” íë¦„ì´ í‘œí˜„ë˜ì–´ ìˆë‹¤.
`fallthrough`ëŠ” `if`ë¬¸ì„ í†µê³¼í•œ í›„ì˜ íë¦„ì„ ë‚˜íƒ€ë‚¸ë‹¤. ì´ ê²½ìš°ì—ëŠ” ë„ë‹¬ í•  ìˆ˜ ì—†ëŠ” ì½”ë“œë¡œ í‘œì‹œë˜ì–´ ìˆë‹¤.\
ì´í•´ë¥¼ ë•ê¸° ìœ„í•´ ê·¸ë¦¼ìœ¼ë¡œ ê·¸ë ¤ë³´ë©´ ì•„ë˜ì™€ ê°™ì€ ëª¨ìŠµì´ë‹¤.
<figure><img src="/post/images/ReactCompiler3/cfg.png" />
<figcaption>ì œì–´ íë¦„ ê·¸ë˜í”„</figcaption>
</figure>

ì•„~ ì´ì œ ì–´ë–¤ ëª¨ìŠµìœ¼ë¡œ ë³€í™˜ë˜ëŠ”ì§€ ê°ì´ ì˜¤ê¸° ì‹œì‘í–ˆë‹¤.\
**êµ¬ë¬¸ë‹¨ìœ„ì˜ íŠ¸ë¦¬**ë¥¼ ì´ëŸ° í˜•íƒœì˜ **ì œì–´ íë¦„ì— ë”°ë¥¸ ê·¸ë˜í”„**ë¡œ í‘œí˜„í•˜ê¸°ìœ„í•œ ë³€í™˜ ê³¼ì •ì´ **Lowering**ì´ë¼ëŠ” ê²ƒì´ë‹¤.\
ê·¸ë¦¬ê³  ê·¸ ë³€í™˜ëœ **í‘œí˜„í˜•íƒœ**ë¥¼ **HIR**ë¼ê³  ë¶€ë¥¸ë‹¤. (React Compiler ì—ì„œ)

## ì¤‘ê°„ í•˜ì°¨ ì§€ì 

ì—¬ê¸°ê¹Œì§€ë§Œ ì‚´í´ë³´ì•„ë„, HIRì´ ì–´ë–¤ ìë£Œêµ¬ì¡°ë¥¼ ì˜ë¯¸í•˜ëŠ”ì§€ ëŒ€ëµì ìœ¼ë¡œ ì•Œ ìˆ˜ ìˆì–´, ì»´íŒŒì¼ ê³¼ì •ì„ ì´í•´í•˜ëŠ”ë°ëŠ” ë¬¸ì œ ì—†ì„ ê²ƒì´ë‹¤. \
ê·¸ë ‡ê¸°ì— ë‹¤ìŒ í¸ìœ¼ë¡œ ë°”ë¡œ ì´ë™í•´ë„ ì¢‹ë‹¤.

Detach!

<YouTube src="https://youtu.be/_GdEsdEfZvc?t=154" />


## ë‹¤ì‹œ lower í•¨ìˆ˜ë¡œ

ë’¤ì— ì´ì–´ì„œëŠ” ë‹¨ìˆœ ì§€ì  í˜¸ê¸°ì‹¬ìœ¼ë¡œ lowering ê³¼ì •ì„ ì‚´í´ë³´ë„ë¡ í•˜ê² ë‹¤. ëª¨ë“  êµ¬ë¬¸ì— ëŒ€í•œ lowering ê³¼ì •ì´ í¬í•¨ë˜ì–´ìˆì–´. ì½”ë“œ ìì²´ëŠ” 4,000ì¤„ ê°€ëŸ‰ ëœë‹¤. \
ê·¸ëŸ¼ ì°¨ê·¼ì°¨ê·¼ ì‚´í´ë³´ë„ë¡ í•˜ì.

ë‹¤ì‹œ ì²˜ìŒìœ¼ë¡œ ëŒì•„ì™€ `lower` í•¨ìˆ˜ë¥¼ ì‚´í´ë³´ì.


```ts
export function lower(
  func: NodePath<t.Function>,
  env: Environment,
  bindings: Bindings | null = null,
  capturedRefs: Array<t.Identifier> = [],
  // the outermost function being compiled, in case lower() is called recursively (for lambdas)
  parent: NodePath<t.Function> | null = null
): Result<HIRFunction, CompilerError> {}
```
`lower` í•¨ìˆ˜ëŠ” ë°”ë²¨ì—ì„œ ë¹„ë¡¯ëœ `NodePath<t.Function>` ë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ì•„ `HIRFunction`ì„ ë°˜í™˜í•œë‹¤. (ì—ëŸ¬ê°€ ë°œìƒí•  ê²½ìš° `CompilerError`ë¥¼ ë°˜í™˜í•œë‹¤.)\
ê¸°íƒ€ ì¸ìë“¤ë¡œëŠ”, `Environment` ê°ì²´, `Bindings`, `capturedRefs`, `parent` ë“±ì´ ìˆë‹¤.

ì´ë•Œ ì…ë ¥ìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” funcì˜ ë‹¨ìœ„ëŠ” ì–´ë–¤ ê²ƒì¸ê°€?\
ì´ì „ì— 1í¸ì—ì„œ ì‚´í´ë´¤ë˜ ê¸°ì–µì„ ë˜ì‚´ë ¤ë³´ì.

program ë…¸ë“œì˜ traverse ë©”ì„œë“œë¥¼ í†µí•´ì„œ ìˆœíšŒí•˜ë©´ì„œ í•¨ìˆ˜ì— ëŒ€í•œ ë…¸ë“œë¥¼ ì°¾ì•„ë‚´ê³ , ê·¸ ë…¸ë“œë¥¼ `compileFn` í•¨ìˆ˜ì— ë„˜ê²¨ì£¼ì—ˆë‹¤.\
ê·¸ë ‡ê¸°ì— `func`ëŠ” ë°”ë²¨ ASTë¡œ ë¶€í„° ë„˜ì–´ì˜¤ëŠ” í•¨ìˆ˜ì— ëŒ€í•œ ë…¸ë“œê°€ ë  ê²ƒì´ë‹¤.\
`FunctionDeclaration`, `FunctionExpression`, `ArrowFunctionExpression` ì´ë ‡ê²Œê°€ ë  ê²ƒì´ë‹¤.

<aside>
ğŸ¤” ë„˜ì–´ê°€ê¸°ì „ì— ì ì‹œë§Œ... ì–´ë¼? ê·¸ëŸ°ë° ë¶„ëª… ìœ„ì—ì„œ `compileFn`ì—ì„œ `lower`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí• ë•ŒëŠ” ì¸ìê°€ ë‘ê°œë°–ì— ì—†ì—ˆëŠ”ë°? ë­”ê°€ ì¸ìë¥¼ ë” ë°›ê³  ìˆë‹¤!
```ts
const hir = lower(func, env).unwrap();
```
ì´ëŠ” `lower` í•¨ìˆ˜ê°€ `lower` í•¨ìˆ˜ë¥¼ **ì¬ê·€ì **ìœ¼ë¡œ í˜¸ì¶œí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.\
`lower`ëŠ” í•¨ìˆ˜ ë‹¨ìœ„ë¡œ HIRë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜ì´ê¸° ë•Œë¬¸ì—, í•¨ìˆ˜ ë‚´ë¶€ì— í•¨ìˆ˜ê°€ ìˆëŠ” ê²½ìš°, ê·¸ í•¨ìˆ˜ì— ëŒ€í•´ì„œë„ `lower` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì•¼ í•œë‹¤.\
ê·¸ë ‡ê¸°ì— ë¶„ëª… ê³¼ì • ì¤‘ì— ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œí•˜ëŠ” ë¶€ë¶„ì´ ìˆì„ ê²ƒì´ê³ , ì´ë•Œ `bindings`, `capturedRefs`, `parent` ë“±ì˜ ì¸ìê°€ í•„ìš”í•  ê²ƒì´ë‹¤. **ë¶„ëª…íˆ!**
</aside>

ì´ì–´ì„œ...

```ts
const builder = new HIRBuilder(env, parent ?? func, bindings, capturedRefs);
const context: Array<Place> = [];
```
`HIRBuilder` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ í• ë‹¹í•´ë‘ê³ , `context` ë°°ì—´ì„ ì´ˆê¸°í™” í•œë‹¤. í•¨ìˆ˜ ì»¨í…ìŠ¤íŠ¸ ì •ë³´ë¥¼ ë‹´ëŠ” ë°°ì—´ì´ë‹¤.

```ts
for (const ref of capturedRefs ?? []) {
  context.push({
    kind: "Identifier",
    identifier: builder.resolveBinding(ref),
    effect: Effect.Unknown,
    reactive: false,
    loc: ref.loc ?? GeneratedSource,
  });
}
```
`capturedRefs` ë°°ì—´ì„ ìˆœíšŒí•˜ë©°, `context` ë°°ì—´ì— `Place` ê°ì²´ë¥¼ ì¶”ê°€í•œë‹¤.\
ì´ë¶€ë¶„ì€ ì¬ê·€ë¡œ í˜¸ì¶œë˜ëŠ” ê²½ìš°ì´ë‹ˆ ë‚˜ì¤‘ì— ë‹¤ì‹œ ë³´ëŸ¬ì˜¤ê¸°ë¡œ í•˜ê³  ì¼ë‹¨ ë„˜ì–´ê°€ì.

### í•¨ìˆ˜ ì´ë¦„ ì¶”ì¶œ(ì‹ë³„ì, Identifier)

í•¨ìˆ˜ê°€ `FunctionDeclaration` ë˜ëŠ” `FunctionExpression`ì¸ ê²½ìš°, í•¨ìˆ˜ì˜ `id`(Identifier) ì‹ë³„ìë¥¼ ê°€ì ¸ì™€ `id` ë³€ìˆ˜ì— í• ë‹¹í•œë‹¤.

```ts
let id: string | null = null;
if (func.isFunctionDeclaration() || func.isFunctionExpression()) {
  const idNode = (
    func as NodePath<t.FunctionDeclaration | t.FunctionExpression>
  ).get("id");
  if (hasNode(idNode)) {
    id = idNode.node.name;
  }
}
```
[**FunctionDeclaration(í•¨ìˆ˜ ì„ ì–¸ì‹)**](https://babeljs.io/docs/babel-types#functiondeclaration) ë…¸ë“œì™€ [**FunctionExpression(í•¨ìˆ˜ í‘œí˜„ì‹)**](https://babeljs.io/docs/babel-types#functionexpression) ë…¸ë“œëŠ” 
ì‹ë³„ìë¥¼ ê°€ì§ˆ ìˆ˜ ìˆì§€ë§Œ, [**ArrowFunctionExpression(í™”ì‚´í‘œ í•¨ìˆ˜)**](https://babeljs.io/docs/babel-types#arrowfunctionexpression) ë…¸ë“œëŠ” ì‹ë³„ìë¥¼ ê°€ì§ˆ ìˆ˜ ì—†ë‹¤.

```js
// FunctionDeclaration
function foo() {}
// FunctionExpression
const foo = function bar() {}
// ArrowFunctionExpression
const foo = () => {}
```

### ì¸ì ì¶”ì¶œ(Parameters)

í•¨ìˆ˜ì˜ ì¸ìë¥¼ ì¶”ì¶œí•˜ê³ , `params` ë°°ì—´ì— `Place` ê°ì²´ë¥¼ ì¶”ê°€í•œë‹¤.
```ts
params: Array<Identifier | Pattern | RestElement> (required)
```
`params`ì—ëŠ” `Identifier`, `Pattern`, `RestElement`ê°€ ì˜¬ ìˆ˜ ìˆë‹¤.\
`Identifier`ëŠ” ì‹ë³„ì, `Pattern`ì€ ê°ì²´ë‚˜ ë°°ì—´ íŒ¨í„´, `RestElement`ëŠ” ë‚˜ë¨¸ì§€ ìš”ì†Œë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.

```ts
const params: Array<Place | SpreadPattern> = [];
func.get("params").forEach((param) => {
  if (param.isIdentifier()) {}
  else if (param.isObjectPattern() || param.isArrayPattern() || param.isAssignmentPattern()) {}
  else if (param.isRestElement()) {}
  else {}
  // ...
});
```

**Identifier(ë‹¨ì¼ ë³€ìˆ˜ ì´ë¦„)**
```ts
// ì˜ˆì‹œ
const greet = function(name) { // nameì´ Identifier
  console.log(`Hello, ${name}!`);
};
```
ì¸ìê°€ `Identifier`ì¸ ê²½ìš°, `Place` ê°ì²´ë¥¼ ìƒì„±í•˜ì—¬ `params` ë°°ì—´ì— ì¶”ê°€í•œë‹¤.

```ts
if (param.isIdentifier()) {
  const binding = builder.resolveIdentifier(param);
  const place: Place = {
    kind: "Identifier",
    identifier: binding.identifier,
    effect: Effect.Unknown,
    reactive: false,
    loc: param.node.loc ?? GeneratedSource,
  };
  params.push(place);
}
```
ì•ìœ¼ë¡œ ìì£¼ ë“±ì¥í•  ê²ƒì¸ë° `Place` ê°ì²´ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ë˜ì–´ ìˆë‹¤.
```ts
/*
 * ë°ì´í„°ë¥¼ ì½ê±°ë‚˜ ì“¸ ìˆ˜ ìˆëŠ” ì¥ì†Œ:
 * - ë³€ìˆ˜(ì‹ë³„ì)
 * - ì‹ë³„ìë¡œì˜ ê²½ë¡œ
 */
export type Place = {
  kind: "Identifier"; // ì¢…ë¥˜
  identifier: Identifier; // ì‹ë³„ì
  effect: Effect; // The effect with which a value is modified. (ìˆ˜ì •ëœ ê°’ì˜ íš¨ê³¼)
  reactive: boolean;
  loc: SourceLocation;
};
```



**ObjectPattern(ê°ì²´ íŒ¨í„´), ArrayPattern(ë°°ì—´ íŒ¨í„´), AssignmentPattern(í• ë‹¹ íŒ¨í„´)**
```ts 
// ì˜ˆì‹œ
// ObjectPattern
const greet = function({ name }) { 
  console.log(`Hello, ${name}!`);
};

// ArrayPattern
const greet = function([name]) { 
  console.log(`Hello, ${name}!`);
};

// AssignmentPattern
const greet = function(name = 'world') { 
  console.log(`Hello, ${name}!`);
};

```
ì¸ìê°€ `ObjectPattern`, `ArrayPattern`, `AssignmentPattern`ì¸ ê²½ìš°, ì„ì‹œ ë³€ìˆ˜ë¥¼ ìƒì„±í•˜ê³  `Place` ê°ì²´ë¥¼ ìƒì„±í•˜ì—¬ `params` ë°°ì—´ì— ì¶”ê°€í•œë‹¤.
`lowerAssignment` í•¨ìˆ˜ë¥¼ í†µí•´ í• ë‹¹ì„ ì²˜ë¦¬í•œë‹¤.

```ts
else if (
  param.isObjectPattern() ||
  param.isArrayPattern() ||
  param.isAssignmentPattern()
) {
  const place: Place = {
    kind: "Identifier",
    identifier: builder.makeTemporary(),
    effect: Effect.Unknown,
    reactive: false,
    loc: param.node.loc ?? GeneratedSource,
  };
  params.push(place);
  lowerAssignment(
    builder,
    param.node.loc ?? GeneratedSource,
    InstructionKind.Let,
    param,
    place,
    "Assignment"
  );
}
```

**RestElement(ë‚˜ë¨¸ì§€ ìš”ì†Œ)**
```ts
// ì˜ˆì‹œ
const greet = function(...names) { 
  console.log(`Hello, ${names.join(', ')}!`);
};
```
ì¸ìê°€ `RestElement`ì¸ ê²½ìš°, ì„ì‹œ ë³€ìˆ˜ë¥¼ ìƒì„±í•˜ê³  `Spread` ê°ì²´ë¥¼ ìƒì„±í•˜ì—¬ `params` ë°°ì—´ì— ì¶”ê°€í•œë‹¤.

```ts
else if (param.isRestElement()) {
  const place: Place = {
    kind: "Identifier",
    identifier: builder.makeTemporary(),
    effect: Effect.Unknown,
    reactive: false,
    loc: param.node.loc ?? GeneratedSource,
  };
  params.push({
    kind: "Spread",
    place,
  });
  lowerAssignment(
    builder,
    param.node.loc ?? GeneratedSource,
    InstructionKind.Let,
    param.get("argument"),
    place,
    "Assignment"
  );
}
```

ì´ë ‡ê²Œ í•¨ìˆ˜ì˜ ì¸ìë¥¼ ì¶”ì¶œí•˜ê³  `params` ë°°ì—´ì— `Place` ê°ì²´ë¥¼ ì¶”ê°€í•˜ëŠ” ê³¼ì •ì„ ê±°ì¹œë‹¤.

ì´ì œ í•¨ìˆ˜ì˜ ë³¸ë¬¸ì„ ì¶”ì¶œí•˜ê³ , `body` ë°°ì—´ì— `Instruction` ê°ì²´ë¥¼ ì¶”ê°€í•˜ëŠ” ê³¼ì •ì„ ì‚´í´ë³´ì.

### í•¨ìˆ˜ ë³¸ë¬¸ ì¶”ì¶œ(Body)

```ts
let directives: Array<string> = [];
const body = func.get("body");
```

í•¨ìˆ˜ì˜ ë³¸ë¬¸ì„ ì¶”ì¶œí•˜ê³ , `directives` ë°°ì—´ì„ ì´ˆê¸°í™”í•œë‹¤.

**Expression(í‘œí˜„ì‹)**


```ts
if (body.isExpression()) {
  const fallthrough = builder.reserve("block");
  const terminal: ReturnTerminal = {
    kind: "return",
    loc: GeneratedSource,
    value: lowerExpressionToTemporary(builder, body),
    id: makeInstructionId(0),
  };
  builder.terminateWithContinuation(terminal, fallthrough);
}
```

**BlockStatement(ë¸”ë¡ë¬¸)**

ë¸”ëŸ­ë¬¸ì¼ ê²½ìš°, `lowerStatement` í•¨ìˆ˜ë¥¼ í†µí•´ `body`ë¥¼ ì²˜ë¦¬í•œë‹¤.

```ts
else if (body.isBlockStatement()) {
  lowerStatement(builder, body);
  directives = body.get("directives").map((d) => d.node.value.value);
}
```

ì´ ë¶€ë¶„ì´ ì‚¬ì‹¤ ì½”ì–´í•œ ë¶€ë¶„ì´ë¼ê³  ë³¼ ìˆ˜ ìˆë‹¤.\
`lowerStatement` í•¨ìˆ˜ë¥¼ ì‚´í´ë³´ì.

```ts
function lowerStatement(
  builder: HIRBuilder,
  stmtPath: NodePath<t.Statement>,
  label: string | null = null
): void {
  const stmtNode = stmtPath.node;
  switch (stmtNode.type) {
    case "ThrowStatement":
    case "ReturnStatement":
    case "IfStatement":
    case "BlockStatement":
    case "BreakStatement":
    case "ContinueStatement":
    case "ForStatement":
    case "WhileStatement":
    case "LabeledStatement":
    case "SwitchStatement":
    case "VariableDeclaration":
    case "ExpressionStatement":
    case "DoWhileStatement":
    case "FunctionDeclaration":
    case "ForOfStatement":
    case "ForInStatement":
    case "DebuggerStatement":
    case "EmptyStatement":
    case "TryStatement":
    // ------- skip -------
    case "TypeAlias":
    case "TSTypeAliasDeclaration":

    // --- unsupported ---
    case "ClassDeclaration":
    // ~
    case "WithStatement":
    default:
```
`stmtPath`(Statement Path)ì˜ ë…¸ë“œ íƒ€ì…ì— ë”°ë¼ ë‹¤ì–‘í•œ ì²˜ë¦¬ë¥¼ í•œë‹¤.\
`lower`í•¨ìˆ˜ì— ì˜í•´ì„œ í˜¸ì¶œë  ë•Œ, `stmtPath`ëŠ” `BlockStatement`ê°€ ë“¤ì–´ì˜¬ ê²ƒì´ë‹¤. ê·¸ëŸ¼ ì˜ˆì‹œë¥¼ í†µí•´ì„œ ì‚´í´ë³´ì.

```tsx
// ì˜ˆì‹œ
function complexExample(x) {
  let result = 0;
  if (x > 0) {
    result = x * 2;
  } else {
    result = x * 3;
  }
  return result;
}
```
í•¨ìˆ˜ `complexExample`ì˜ bodyëŠ” `BlockStatement`ì´ë‹¤. ì´ `BlockStatement`ë¥¼ `lowerStatement` í•¨ìˆ˜ì— ë„˜ê²¨ë³´ì.

```ts
case "BlockStatement": {
  const stmt = stmtPath as NodePath<t.BlockStatement>;
  const statements = stmt.get("body");
```
`stmtPath`ë¥¼ `BlockStatement`ë¡œ íƒ€ì… ìºìŠ¤íŒ…í•˜ê³ , `body`ë¥¼ ì¶”ì¶œí•œë‹¤.\
`body`ëŠ” `NodePath<t.Statement>[]` íƒ€ì…ìœ¼ë¡œ, ë¸”ë¡ë¬¸ ë‚´ì˜ ê° ë¬¸ì¥ì„ ë‚˜íƒ€ë‚¸ë‹¤.

```ts
for (const s of statements) {
  lowerStatement(builder, s);
}
```
**statements**ë“¤ì„ ìˆœíšŒ í•˜ë©´ì„œ, `lowerStatement` í•¨ìˆ˜ë¥¼ ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œí•œë‹¤.

blockStatment ì²˜ë¦¬ ì¤‘ì— ì¬ê·€ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ê³¼ì •ë§ê³ ë„ ë‹¤ë¥¸ ê³¼ì •ì´ í•˜ë‚˜ ë” ìˆë‹¤.

#### 'const' ë³€ìˆ˜ ì„ ì–¸ì˜ Hoisting ì²˜ë¦¬

ë¨¼ì € ì–´ë–¤ ë°”ì¸ë”©ì´ ì„ ì–¸ë˜ê¸° ì „ì— ì°¸ì¡°ë  ê²½ìš° í˜¸ì´ìŠ¤íŒ…ë  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•œ ë’¤,\
í•´ë‹¹ ì„ ì–¸ì„ ì°¸ì¡°ë˜ëŠ” ê°€ì¥ ë¹ ë¥¸ ì§€ì (ì¦‰, ë°”ë¡œ ì•ì˜ ìµœìƒìœ„ ë¬¸)ìœ¼ë¡œ ì»¨í…ìŠ¤íŠ¸ ë³€ìˆ˜ë¡œ í˜¸ì´ìŠ¤íŒ…í•œë‹¤.\


```ts
const hoistableIdentifiers: Set<t.Identifier> = new Set();

for (const [, binding] of Object.entries(stmt.scope.bindings)) {
  // refs to params are always valid / never need to be hoisted
  if (binding.kind !== "param") {
    hoistableIdentifiers.add(binding.identifier);
  }
}
```
`hoistableIdentifiers`ë¼ëŠ” `Set`ì„ ìƒì„±í•˜ê³ , `stmt.scope.bindings`ë¥¼ ìˆœíšŒí•˜ë©° 
identifier ë“¤ì„ `hoistableIdentifiers`ì— ì¶”ê°€í•œë‹¤.\
stmt.scope.bindingsëŠ” í˜„ì¬ ë¸”ë¡ì˜ ë°”ì¸ë”© ì •ë³´ë¥¼ ë‹´ê³  ìˆë‹¤.\
ë¶€ëª¨ë‚˜ ìì‹ ë¸”ë¡ì˜ ë°”ì¸ë”© ì •ë³´ëŠ” í¬í•¨í•˜ì§€ ì•ŠëŠ”ë‹¤.\
ì´ë•Œ, `const`, `let`, `var`ì´ `hoistableIdentifiers`ì— ì¶”ê°€ëœë‹¤.

<aside>
**[ì§ì ‘ ì‹¤í–‰í•´ë³´ê¸°]**\
playgroundë¥¼ í†µí•´ì„œ ì‹¤í–‰í•´ë³¼ ìˆ˜ ë„ ìˆì§€ë§Œ, í˜„ì¬ playground ì½”ë“œ ìì²´ë„ ì»´íŒŒì¼ëŸ¬ê°€ ëŒì•„ì„œ playgroundì˜ ì»´íŒŒì¼ ê²°ê³¼ë„ ì„ì—¬ì„œ ë‚˜ì˜¨ë‹¤ ê·¸ë˜ì„œ ëª…í™•í•˜ê²Œ í™•ì¸í•˜ê¸° ì–´ë µë‹¤.\
ë”°ë¼ì„œ, ë¡œì»¬ì—ì„œ ì§ì ‘ ì‹¤í–‰í•´ë³´ì.
```js
const babel = require('@babel/core');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;

const code = `
function complexExample(x) {
  let result = 0;
  const a = 1;
  var b = 10;
  function foo() {
    return a;
  }
  if (x > 0) {
    const c = 100;
    result = x * 2;
  } else {
   function bar() {
     return a;
    }
    result = x * 3;
  }
  return result;
}
`;

const ast = parser.parse(code);

traverse(ast, {
  BlockStatement(path) {
    console.log("--- Block ---")
    const bindings = path.scope.bindings;
    for(const [, binding] of Object.entries(bindings)) {
      if (binding.kind !== "param") {
        console.log(binding.identifier);
      }
    }
    console.log("--- End Block ---")
  }
});
```
ì‹¤í–‰íˆë³´ë©´, ë©”ì¸ blockì—ì„œ í˜„ì¬ ë¸”ëŸ­ì—ë§Œ ìˆëŠ” `result`, `a`, `foo`ê°€ consoleì— ì°íˆëŠ” ê²ƒ(`hoistableIdentifiers`ì— ì¶”ê°€ë˜ëŠ” ê²ƒ)ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
```js
Node {
  type: "Identifier",
  name: "result",
  //...
}
Node {
  type: "Identifier",
  name: "a",
  //...
}
Node {
  type: "Identifier",
  name: "foo",
  //...
}
```
</aside>

ê° ë¬¸ì„ ìˆœíšŒí• ë•Œ, í˜¸ì´ìŠ¤íŒ…ì´ í•„ìš”í•œ ìš”ì†Œë“¤ì„ ë„£ì„ `willHoist`ë¼ëŠ” `Set`ì„ ìƒì„±í•œë‹¤.

```ts
for (const s of statements) {
  const willHoist = new Set<NodePath<t.Identifier>>();
  // ...
}
```

í•¨ìˆ˜ ì»¨í…ìŠ¤íŠ¸ì˜ ê¹Šì´ë¥¼ ì¶”ì í•œë‹¤. ì‹ë³„ì ì°¸ì¡°ê°€ ë‚´ë¶€ í•¨ìˆ˜ì—ì„œ ë°œìƒí•˜ëŠ”ì§€ ì¶”ì í•˜ê¸° ìœ„í•´ì„œì´ë‹¤.\
`traverse`ë¥¼ í†µí•´ íƒìƒ‰í•˜ë©´ì„œ `FunctionExpression`, `FunctionDeclaration`, `ArrowFunctionExpression`, `ObjectMethod` ë…¸ë“œë¥¼ ë§Œë‚˜ë©´ í•¨ìˆ˜ ê¹Šì´ë¥¼ ì¦ê°€ì‹œí‚¤ê³ , ë…¸ë“œë¥¼ ë¹ ì ¸ë‚˜ì˜¤ë©´ í•¨ìˆ˜ ê¹Šì´ë¥¼ ê°ì†Œì‹œí‚¨ë‹¤.
```ts
let fnDepth = s.isFunctionDeclaration() ? 1 : 0;
const withFunctionContext = {
  enter: (): void => {
    fnDepth++; // í•¨ìˆ˜ ê¹Šì´ ì¦ê°€
  },
  exit: (): void => {
    fnDepth--; // í•¨ìˆ˜ ê¹Šì´ ê°ì†Œ
  },
};
s.traverse({
  FunctionExpression: withFunctionContext, // í•¨ìˆ˜ í‘œí˜„ì‹
  FunctionDeclaration: withFunctionContext, // í•¨ìˆ˜ ì„ ì–¸ì‹
  ArrowFunctionExpression: withFunctionContext,  // í™”ì‚´í‘œ í•¨ìˆ˜
  ObjectMethod: withFunctionContext, // ê°ì²´ ë©”ì„œë“œ
  // ...
});
```

ë¬¸ì„ ìˆœíšŒí•˜ë©´ì„œ, ì‹ë³„ìë¥¼ ì°¾ëŠ”ë‹¤.\
ì‹ë³„ìê°€ ì°¸ì¡°ë˜ì§€ ì•Šê±°ë‚˜, ë¶€ëª¨ê°€ í• ë‹¹ í‘œí˜„ì‹ì´ ì•„ë‹Œ ê²½ìš°, ë„˜ì–´ê°„ë‹¤.\
ì‹ë³„ìê°€ ì°¸ì¡°ë˜ê³  `hoistableIdentifiers`ì— ìˆìœ¼ë©°, í•¨ìˆ˜ ê¹Šì´ê°€ 0ë³´ë‹¤ í¬ê±°ë‚˜ ë°”ì¸ë”©ì´ `hoisted`ì¸ ê²½ìš°, `willHoist`ì— ì¶”ê°€í•œë‹¤.

```ts
s.traverse({
  // ...
  Identifier(id: NodePath<t.Identifier>) {
    const id2 = id;
    if (
      !id2.isReferencedIdentifier() &&
      // isReferencedIdentifier is broken and returns false for reassignments
      id.parent.type !== "AssignmentExpression"
    ) {
      return;
    }
    const binding = id.scope.getBinding(id.node.name);
    /*
    * ì‹ë³„ì ì„ ì–¸ì„ í˜¸ì´ìŠ¤íŠ¸í•  ìˆ˜ ìˆëŠ” ê²½ìš°ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
    * 1. ì°¸ì¡°ê°€ ë‚´ë¶€ í•¨ìˆ˜ ë‚´ì—ì„œ ë°œìƒí•˜ëŠ” ê²½ìš°
    * ë˜ëŠ”
    * 2. ì„ ì–¸ ìì²´ê°€ í˜¸ì´ìŠ¤íŠ¸ ê°€ëŠ¥í•œ ê²½ìš°
    */
    if (
      binding != null &&
      hoistableIdentifiers.has(binding.identifier) &&
      (fnDepth > 0 || binding.kind === "hoisted")
    ) {
      willHoist.add(id);
    }
  },
});
```
ì´í›„ ë‹¤ì‹œ ë…¸ë“œë¥¼ ìˆœíšŒí•˜ë©´ì„œ, `hoistableIdentifiers`ì— ìˆëŠ” ì‹ë³„ìë¥¼ ì‚­ì œí•œë‹¤.

```ts
s.traverse({
  Identifier(path: NodePath<t.Identifier>) {
    if (hoistableIdentifiers.has(path.node)) {
      hoistableIdentifiers.delete(path.node);
    }
  },
});
```

`willHost`ë¥¼ ìˆœíšŒí•˜ë©´ì„œ, `identifier`ë¥¼ `resolveIdentifier`ë¥¼ í†µí•´ ê³ ìœ í•œ ì‹ë³„ìë¡œ ë³€í™˜í•˜ê³ ,
`lowerValueToTemporary` í•¨ìˆ˜ í†µí•´ ì„ì‹œë³€ìˆ˜ì— `DeclareContext`ë¥¼ ìƒì„±í•˜ê³  **builderì— push**í•œë‹¤.\
ì´í›„ ì „ì—­ í™˜ê²½ì˜ `#contextIdentifiers`, `#hoistedIdentifiers`ì— ì¶”ê°€í•œë‹¤.


```ts
// Hoist declarations that need it to the earliest point where they are needed
for (const id of willHoist) {
  const binding = stmt.scope.getBinding(id.node.name);
  if (builder.environment.isHoistedIdentifier(binding.identifier)) {
    // Already hoisted
    continue;
  }
  const identifier = builder.resolveIdentifier(id);
  const place: Place = {
    effect: Effect.Unknown,
    identifier: identifier.identifier,
    kind: "Identifier",
    reactive: false,
    loc: id.node.loc ?? GeneratedSource,
  };
  lowerValueToTemporary(builder, {
    kind: "DeclareContext",
    lvalue: {
      kind: InstructionKind.HoistedConst,
      place,
    },
    loc: id.node.loc ?? GeneratedSource,
  });
  builder.environment.addHoistedIdentifier(binding.identifier);
```
ë‚˜ì¤‘ì— ì½”ë“œ ìƒì„± ì „ì— `DeclareContext`ë¥¼ ì œê±°í•˜ê³  ì—°ê´€ëœ `StoreContext`ë¥¼ ë‹¤ì‹œ ë³€í™˜í•˜ì—¬ ì›ë˜ ì†ŒìŠ¤ ì½”ë“œë¥¼ ë³µì›í•œë‹¤.\
ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ì„ ì–¸ì— ëŒ€í•œ í˜¸ì´ìŠ¤íŒ…ì€ í–¥í›„ êµ¬í˜„ë  ì˜ˆì •ì´ë‹¤.

#### í˜¸ì´ìŠ¤íŒ…(Hoisting)ì„ í•˜ëŠ” ì´ìœ ê°€ ë­˜ê¹Œ?

<aside>
**javascriptì˜ í˜¸ì´ìŠ¤íŒ…**\
javascriptì—ì„œ í˜¸ì´ìŠ¤íŒ…ì€ ë³€ìˆ˜ì˜ ì„ ì–¸ì„ ìœ íš¨ ë²”ìœ„ì˜ ìµœìƒë‹¨ìœ¼ë¡œ ëŒì–´ì˜¬ë¦¬ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.\
ìë°”ìŠ¤í¬ë¦½íŠ¸ëŠ” ì½”ë“œë¥¼ ì‹¤í–‰í•˜ê¸° ì „ì— í•¨ìˆ˜ ì„ ì–¸ë¬¸ê³¼ ë³€ìˆ˜ ì„ ì–¸ë¬¸ì„ ë©”ëª¨ë¦¬ì— ì €ì¥í•˜ê¸° ë•Œë¬¸ì—, í•¨ìˆ˜ ì„ ì–¸ë¬¸ê³¼ ë³€ìˆ˜ ì„ ì–¸ë¬¸ì„ ëŒì–´ì˜¬ë¦¬ëŠ” ê²ƒì´ë‹¤.\
**const**ì˜ ê²½ìš°ëŠ” í˜¸ì´ìŠ¤íŒ…ì€ ë˜ì§€ë§Œ, TDZ(Temporal Dead Zone)ì— ë¹ ì§€ê²Œ ëœë‹¤.

ì—¬ê¸°ê¹Œì§€ê°€ ìš°ë¦¬ê°€ ì•Œê³  ìˆë˜ ì¼ë°˜ì ì¸ javascriptì˜ í˜¸ì´ìŠ¤íŒ…ì´ë‹¤.
</aside>

ê·¸ëŸ°ë°, ì´ë²ˆì— ì‚´í´ë³¸ ê²ƒì€ ì»´íŒŒì¼ëŸ¬ê°€ í•˜ëŠ” í˜¸ì´ìŠ¤íŒ…ì´ë‹¤.\
<aside>ğŸ¤” ì—¬ê¸°ì„œë¶€í„°ëŠ” ì´ì œ ì¶”ì¸¡ì´ë‹¤.</aside>
**const í˜¸ì´ìŠ¤íŒ…**ì„ í•´ì£¼ëŠ” ì´ìœ ëŠ”, ë­˜ê¹Œ? ì˜ˆì‹œì™€ í•¨ê»˜ ì‚´í´ë³´ì. í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ í†µí•´ ë³´ë©´ ì–‘ì§ˆì˜ ì˜ˆì‹œë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤. `/src/__tests__/fixtures/compiler` ë¡œ ì´ë™í•´ë³´ì.\
ê°„ê²°í•´ë³´ì´ëŠ” ì½”ë“œ í•˜ë‚˜ë¥¼ ì¤ì—ˆë‹¤. "hoisting-simple-const-declaration.expected.md" íŒŒì¼ì„ ì—´ì–´ë³´ì.

```js
function hoisting() {
  const foo = () => {
    return bar + baz;
  };
  const bar = 3;
  const baz = 2;
  return foo(); // OK: called outside of TDZ for bar/baz
}
```
ê°„ë‹¨í•œ í˜¸ì´ìŠ¤íŒ… ì˜ˆì œì´ë‹¤. ì´ê±¸ **HIRë¡œ ë³€í™˜**í•˜ë©´ ì•„ë˜ì™€ ê°™ì´ ë³€í•œë‹¤.

```js
function hoisting
bb0 (block):
  [1] <unknown> $1 = DeclareContext HoistedConst <unknown> bar$0
  [2] <unknown> $3 = DeclareContext HoistedConst <unknown> baz$2
  [3] <unknown> $4 = LoadContext <unknown> bar$0
  [4] <unknown> $5 = LoadContext <unknown> baz$2
  [5] <unknown> $10 = Function  @deps[<unknown> $4,<unknown> $5] @context[<unknown> bar$0,<unknown> baz$2] @effects[]:
      bb1 (block):
        [1] <unknown> $6 = LoadContext <unknown> bar$0
        [2] <unknown> $7 = LoadContext <unknown> baz$2
        [3] <unknown> $8 = Binary <unknown> $6 + <unknown> $7
        [4] Return <unknown> $8
  [6] <unknown> $12 = StoreLocal Const <unknown> foo$11 = <unknown> $10
  [7] <unknown> $13 = 3
  [8] <unknown> $14 = StoreContext Reassign <unknown> bar$0 = <unknown> $13
  [9] <unknown> $15 = 2
  [10] <unknown> $16 = StoreContext Reassign <unknown> baz$2 = <unknown> $15
  [11] <unknown> $17 = LoadLocal <unknown> foo$11
  [12] <unknown> $18 = Call <unknown> $17()
  [13] Return <unknown> $18
```
ë§¨ ìœ„ì˜`DeclareContext HoistedConst`ë¥¼ í†µí•´ `bar`, `baz`ê°€ í˜¸ì´ìŠ¤íŒ… ë˜ì—ˆìŒì„ ì•Œ ìˆ˜ ìˆë‹¤.\
í  ì—¬ê¸°ê¹Œì§€ ë´¤ì„ë• ë”±íˆ ë­”ê°€ ì™€ë‹¿ëŠ” ê²ƒì´ ì—†ë‹¤.

ê·¸ë ‡ë‹¤ë©´ ì´ì œ **í˜¸ì´ìŠ¤íŒ…ì„ ë‹¤ ë„ê³ ** ìƒì„±í•´ë³´ì. ì „ë¶€ ì£¼ì„ì²˜ë¦¬ í•˜ê³  ì»´íŒŒì¼ëŸ¬ë¥¼ ë‹¤ì‹œ ëŒë ¤ë³´ì•˜ë‹¤.

```ts
// ğŸ˜´
case "BlockStatement": {
  const stmt = stmtPath as NodePath<t.BlockStatement>;
  const statements = stmt.get("body");
  // const hoistableIdentifiers: Set<t.Identifier> = new Set();
  // for (const [, binding] of Object.entries(stmt.scope.bindings)) {
  //   // refs to params are always valid / never need to be hoisted
  //   if (binding.kind !== "param") {
  //     hoistableIdentifiers.add(binding.identifier);
  //   }
  // }

  for (const s of statements) {
    // const willHoist = new Set<NodePath<t.Identifier>>();
    // /*
    //  * If we see a hoistable identifier before its declaration, it should be hoisted just
    //  * before the statement that references it.
    //  */
    // let fnDepth = s.isFunctionDeclaration() ? 1 : 0;
    // const withFunctionContext = {
    //   enter: (): void => {
    //     fnDepth++;
    //   },
    //   exit: (): void => {
    //     fnDepth--;
    //   },
    // ...
    lowerStatement(builder, s);
  }
```
ìš°ì„  ì´ëŸ° ì—ëŸ¬ê°€ ë°œìƒí–ˆë‹¤.
```plaintext
Todo: [hoisting] EnterSSA: Expected identifier to be defined before being used. \
Identifier bar$0 is undefined (5:5)
```
ë­”ê°€ ë‹¬ë¼ì¡Œë‹¤. `bar$0`ì´ ì •ì˜ë˜ê¸° ì „ì— ì‚¬ìš©ë˜ì—ˆë‹¤ëŠ” ì—ëŸ¬ê°€ ë°œìƒí–ˆë‹¤.\
**HIR** ì½”ë“œë„ ì‚´í´ë³´ì. **ì–´ë–¤ ì°¨ì´**ê°€ ìƒê²¼ì„ê¹Œ?

```js
function hoisting
bb0 (block):
  [1] <unknown> $1 = LoadLocal <unknown> bar$0
  [2] <unknown> $3 = LoadLocal <unknown> baz$2
  [3] <unknown> $8 = Function  @deps[<unknown> $1,<unknown> $3] @context[<unknown> bar$0,<unknown> baz$2] @effects[]:
      bb1 (block):
        [1] <unknown> $4 = LoadLocal <unknown> bar$0
        [2] <unknown> $5 = LoadLocal <unknown> baz$2
        [3] <unknown> $6 = Binary <unknown> $4 + <unknown> $5
        [4] Return <unknown> $6
  [4] <unknown> $10 = StoreLocal Const <unknown> foo$9 = <unknown> $8
  [5] <unknown> $11 = 3
  [6] <unknown> $12 = StoreLocal Const <unknown> bar$0 = <unknown> $11
  [7] <unknown> $13 = 2
  [8] <unknown> $14 = StoreLocal Const <unknown> baz$2 = <unknown> $13
  [9] <unknown> $15 = LoadLocal <unknown> foo$9
  [10] <unknown> $16 = Call <unknown> $15()
  [11] Return <unknown> $16
```
ì˜¤... `DeclareContext HoistedConst`ê°€ ì‚¬ë¼ì¡Œë‹¤. ì´ê±´ ë‹¹ì—°í•˜ê² ì§€. **í˜¸ì´ìŠ¤íŒ…**ì„ í•˜ì§€ ì•Šì•˜ìœ¼ë‹ˆê¹Œ.\
ê·¸ë¡œì¸í•´ **[1]** ì—ì„œ ì •ì˜ë˜ê¸° ì „ì— `LoadLocal`ì´ ë°œìƒí•˜ì—¬ ì—ëŸ¬ê°€ ë°œìƒí•œ ê²ƒì´ë‹¤. ë’¤ëŠ¦ê²Œ **[6]**, **[8]**,ì—ì„œ `StoreLocal Const`ë¡œ ì •ì˜ë˜ì—ˆì§€ë§Œ, ì´ë¯¸ ì‚¬ìš©ë˜ì—ˆê¸° ë•Œë¬¸ì— ì—ëŸ¬ê°€ ë°œìƒí–ˆë‹¤.

javascriptê°€ ì‹¤í–‰ë˜ëŠ” í™˜ê²½ì—ì„œëŠ” ì—”ì§„ì´ í˜¸ì´ìŠ¤íŒ…ì„ í•´ì£¼ì§€ë§Œ, HIRë¡œ ë³€í™˜ë˜ê³ ë‚˜ë©´ ë‹¤ë¥¸ ì–¸ì–´ë¡œ ë³€í™˜ëœ ê²ƒì´ë‚˜ ë‹¤ë¦„ì—†ë‹¤.
ê·¸ë ‡ê¸°ì—, ìµœëŒ€í•œ javascriptë¥¼ ëª¨ë¸ë§í•˜ì—¬ì•¼ í–ˆë˜ ê²ƒì´ì§€ ì•Šì„ê¹Œ ì‹¶ë‹¤. 
ê·¸ì™¸ì—ë„ ì´ë¡œì¸í•´ DCEë‚˜ Const Propagation ë“± ë‹¤ë¥¸ ìµœì í™” ê³¼ì •ì—ì„œë„ ë‚˜ì¤‘ì— í™œìš©í•  ìˆ˜ ìˆì§€ ì•Šì„ê¹Œ ì‹¶ì€ ìƒê°ì„ ë‚¨ê²¨ë³¸ë‹¤.

ê·¸ë˜ì„œ ê¶ê¸ˆí•´ì„œ Compiler ê°œë°œì lauren ì—ê²Œ ë¬¼ì–´ë³´ì•˜ë‹¤. ì§ˆë¬¸ì„ ë˜ì§€ê³ ë‚˜ì„œì•¼ ë¨¸ì“±í•˜ê²Œ ì˜ˆì œ ì½”ë“œë¥¼ ì°¾ì•„ë³´ê²Œ ë˜ì—ˆê³  êµ¬í˜„ì´ í•„ì—°ì ì´ì—ˆìŒì„ ì•Œê²Œ ë˜ì—ˆë‹¤.\
(ì§ˆë¬¸ ì•ìª½ì´ í•˜ë‚˜ ì˜ë¦¬ê¸´í–ˆëŠ”ë°)
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">itâ€™s more because itâ€™s a todo ğŸ¤£ const hoisting was the most straightforward to support, and at the moment itâ€™s not used in any other passes</p>&mdash; lauren ë‚˜ì€ (@potetotes) <a href="https://twitter.com/potetotes/status/1799899243395604762?ref_src=twsrc%5Etfw">June 9, 2024</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

ìš”ëŸ° ì¹œì ˆí•œ ë‹µë³€ì„ ë°›ì•˜ë‹¤. ê¶ê¸ˆí•  ë•Œ ë°”ë¡œ ì§ˆë¬¸ í•´ë³¼ ìˆ˜ ìˆëŠ” ìš©ê¸°ê°€(?) ì¡°ê¸ˆ ìƒê¸´ ê²ƒ ê°™ë‹¤.\
**const hoisting**ì´ ê°€ì¥ ê°„ë‹¨í•˜ê²Œ ì§€ì›í•  ìˆ˜ ìˆëŠ” í˜•íƒœì˜€ê¸°ì—, ë¨¼ì € êµ¬í˜„ ë˜ì—ˆê³ , ì•„ì§ ë‹¤ë¥¸ ìµœì í™” ê³¼ì •ì—ì„œ ì‚¬ìš©ë˜ì§€ ì•Šì•˜ë‹¤ê³  í•œë‹¤.

ê·¸ë ‡ë‹¤ë©´, ì´ì œ ë‹¤ì‹œ `lowerStatement` í•¨ìˆ˜ë¡œ ëŒì•„ê°€ì„œ, ë‹¤ë¥¸ ë¶€ë¶„ì„ ì‚´í´ë³´ë„ë¡ í•˜ì.
ì´ì œ ì¬ê·€ì ìœ¼ë¡œ ëŒë©´ì„œ ê°ì¼€ì´ìŠ¤ì— ë§ëŠ” loweringì„ ìˆ˜í–‰í•  ê²ƒì´ë‹¤. ì´ ê²ƒì„ ë‹¤ ì ê³  ìˆë…¸ë¼ë©´, ì½ëŠ” ì´ë„ ì§€ë£¨í•  ê²ƒ ê°™ì•„ì„œ. ë‹¤ìŒì— ì§¤ë§‰í•˜ê²Œ ëª‡ê°œë§Œ ì‚´í´ë³´ê±°ë‚˜ ì´ë²ˆ ê¸€ì— ë‚˜ì¤‘ì— ì²¨ë¶€í•´ë‘ê² ë‹¤. 
ì¨‹ë“  ì¬ê·€ì ìœ¼ë¡œ body ë¶€ë¶„ì„ lowering í•˜ê³  ë‚˜ë©´ ì•„ë˜ë¡œ ë¹ ì ¸ë‚˜ì˜¤ê²Œ ëœë‹¤. 

```ts
builder.terminate(
  {
    kind: "return",
    loc: GeneratedSource,
    value: lowerValueToTemporary(builder, {
      kind: "Primitive",
      value: undefined,
      loc: GeneratedSource,
    }),
    id: makeInstructionId(0),
  },
  null
);

return Ok({
  id,
  params,
  fnType: parent == null ? env.fnType : "Other",
  returnType: null, // TODO: extract the actual return type node if present
  body: builder.build(),
  context,
  generator: func.node.generator === true,
  async: func.node.async === true,
  loc: func.node.loc ?? GeneratedSource,
  env,
  effects: null,
  directives,
});
```

`builder.terminate`ë¥¼ í†µí•´ `return`ì„ ìƒì„±í•˜ê³ , `builder.build()`ë¥¼ í†µí•´ ìƒì„±í•˜ì—¬ ë°˜í™˜í•œë‹¤.\
ê·¸ë ‡ê²Œ `HIRFunction`ì„ ë°˜í™˜í•˜ê²Œ ëœë‹¤.
```ts
const hir = lower(func, env).unwrap();
```
**HIR**ë¡¤ ë³€í™˜í•˜ëŠ” ê³¼ì •ì—ì„œ builderê°€ ë§ì€ ì—­í• ì„ í•˜ëŠ”ë°, ì´ëŠ” ê¹Šê²Œ ì‚´í´ë³´ì§€ ëª»í–ˆë‹¤. ì´ëŠ” ë‹¤ìŒì— ë” êµ¬ì²´ì ìœ¼ë¡œ ì‚´í´ë³´ë„ë¡ í•˜ê² ë‹¤.

## ë§ˆë¬´ë¦¬

ì´ë²ˆ ê¸€ì—ì„œëŠ” `lower` í•¨ìˆ˜ë¥¼ ì‚´í´ë³´ì•˜ë‹¤. 
- `lower` í•¨ìˆ˜ëŠ” ë°”ë²¨ ASTë¡œ ë¶€í„° `HIRFunction`ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.
- í•¨ìˆ˜ì˜ ì¸ì, ì‹ë³„ì, ë³¸ë¬¸ì„ ì¶”ì¶œí•˜ê³  `HIRBuilder`ë¥¼ í†µí•´ `Instruction` ê°ì²´ë¥¼ ìƒì„±í•œë‹¤.
- `const` ë³€ìˆ˜ ì„ ì–¸ì˜ í˜¸ì´ìŠ¤íŒ…ì„ ì²˜ë¦¬í•œë‹¤.
- `lowerStatement` í•¨ìˆ˜ë¥¼ í†µí•´ ê°ì¢… ë¬¸ì„ ì²˜ë¦¬í•œë‹¤.
- `lower` í•¨ìˆ˜ëŠ” ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œë˜ë©°, í•¨ìˆ˜ì˜ ë³¸ë¬¸ì„ ì²˜ë¦¬í•˜ê³  `HIRFunction`ì„ ë°˜í™˜í•œë‹¤.

ê·¸ëŸ¼ ì•ˆë…•!


ì´ìš©í•œ íˆ´
- [AST Explorer](https://astexplorer.net/)
- [Babel](https://babel.dev/)


ì°¸ê³ ìë£Œ
- https://groups.seas.harvard.edu/courses/cs153/2018fa/lectures/Lec17-CFG-dataflow.pdf
- https://rustc-dev-guide.rust-lang.org/hir.htmlimport 


